[{"content":"Introduction In this post, I\u0026rsquo;d like to write a quick summary of key ideas presented in the book The Pragmatic Programmer written by David Thomas and Andrew Hunt. It will serve me (and you, hopefully) as a reference I can look up later to remind myself of these timeless concepts.\nObviously, it\u0026rsquo;s not possible to cover everything here. I highly recommend reading this book to get a full picture. Here, I focus on things that are in my opinion most important in regards to our everyday work and advancing our careers as programmers.\nThis book is not strictly about code. It\u0026rsquo;s not examining a specific language, tool, framework, or pattern. It\u0026rsquo;s about a philosophy of being pragmatic in our craft. It\u0026rsquo;s aimed at people who want to become more effective and productive programmers.\nThe word pragmatic comes from the Latin pragmaticus, which means “skilled in business”. Let\u0026rsquo;s see what the authors think it means to be a pragmatic programmer.\nTakeaways The ideas listed below are presented in the same order as they appear in the book. The order doesn\u0026rsquo;t imply importance. This means that the last idea is not the least important or useful.\nCraftsmanship Programming is a craft and it\u0026rsquo;s a difficult job. No doubt about it. Every day, we try to transform vague user requirements into a language that computers can understand.\nThe authors compare programmers to craftsmen who employ a set of good-quality tools and can choose the best one for the job at hand. We ought to do the same thing. It\u0026rsquo;s not enough to learn one language and stick with it throughout our entire career. We should aspire to be polyglots that can adapt to the current situation by utilizing the best possible tools to solve the problem.\n If all you have is a hammer, everything looks like a nail.\n In an attempt to become pragmatic, we must also ask questions and be curious. How does this library work? Why did you decide to do it this way? Is it the best way to solve this? This will deepen our understanding, broaden our perspective and lead to a feeling of mastery and continuous improvement.\nBe responsible and don\u0026rsquo;t complain Pragmatic programmers aren\u0026rsquo;t afraid to admit ignorance or error. We are humans. A lot of things can go wrong even if we do our best with testing, documentation, or automation. The question is not if it happens, but when. It\u0026rsquo;s unavoidable.\nThe best we can do then is to acknowledge the problem, take responsibility for it, and try to offer options to fix it. Unfortunately, what we usually do instead is complain. We blame someone or something else - coworkers, programming languages, tools, etc.\nImagine that it wasn\u0026rsquo;t our code that introduced the error, but someone else\u0026rsquo;s. It doesn\u0026rsquo;t matter. We all work towards the same goal. If we help our teammates, they will do the same thing for us later. This builds a healthy relationship in the team. Others will also remember that you can be trusted.\n Suggest options. Don\u0026rsquo;t make excuses.\n Before I approach anyone and tell them why something can\u0026rsquo;t be done or that it\u0026rsquo;s not my fault, I stop and listen to myself. How does this excuse sound? What will they think of me?\nI try to position myself in their shoes. How do I react when someone (such as an auto mechanic) comes to me with a lame excuse? What do I think of them or their company after that?\nDon\u0026rsquo;t accept any broken window The authors describe a phenomenon of cities where some buildings are in perfectly well shape while others have gone really bad. Researchers discovered that there exists a trigger mechanism that can quickly turn a beautiful and clean building into an abandoned derelict.\nWhat is that trigger? A broken window.\nHere is what they found:\n One broken window, left unrepaired for any substantial length of time, instills in the inhabitants of the building a sense of abandonment—a sense that the powers don’t care about the building. So another window gets broken. People start littering. Graffiti appears. Serious structural damage begins. [\u0026hellip;]\n In my opinion, this analogy suits software quite well. I\u0026rsquo;m sure we\u0026rsquo;ve all seen codebases that were doing just fine only to find later that they are slowly descending to a ruin.\nA broken window could be any shortcut that we\u0026rsquo;ve taken to make things easier for us at the moment. A broken design or architecture, wrong decision, poor or dirty code.\nIf we allow a single broken window in our codebase, we can be sure that there will be more to come.\nYour growth is your responsibility We all know we should stay on top of technologies and the latest trends and constantly keep learning. I think no one has to be convinced about this anymore.\nWhat I like about this book is that it gives us some very specific guidelines for building our knowledge portfolio that we can take inspiration from:\n Learn at least one new language every year. You\u0026rsquo;ll learn several different approaches to solving various problems. It\u0026rsquo;ll broaden your thinking. Read a technical book each month. A book will give you the depth that you won\u0026rsquo;t find in podcasts, blog posts, or online videos. Take classes or workshops. Look for occasions to expand your knowledge. Participate in local user groups or meetups. Don\u0026rsquo;t just go and listen. Participate actively. Experiment with different environments. For example, if you\u0026rsquo;ve only worked with IDE, consider spending some time with a text editor, and vice versa. Stay current. Follow interesting people in your field, read blogs, make side-projects.  Easier To Change Programmers often like to argue and discuss which framework, language, or design pattern is the best.\nWhen we learn to program, we are taught about different rules or principles that we are supposed to follow. YAGNI (You Aren\u0026rsquo;t Gonna Need It), DRY (Don\u0026rsquo;t Repeat Yourself), KISS (Keep It Simple, Stupid) the Law of Demeter, and a whole bunch of others.\nAuthors argue that at the end of the day, what really matters is that the system we are working on is Easier To Change (ETC).\nWhy should we favor composition over inheritance? Because it makes things easier to change.\nWhy is decoupling useful? Because by isolating concerns we make them easier to change.\nWhy do we always make sure to follow the Single Responsibility rule? Because if there is a change in the requirements, we only have to touch a single module. ETC.\nETC is a value, not a rule, that should help you make decisions. By asking whether the approach I\u0026rsquo;m taking will make it relatively easy to change it later when needed, you will usually know which path to choose.\nPrototypes and Tracer Bullets One of the ideas behind prototyping is that you will throw away every piece of code you wrote to explore or try the concept.\nFor example, to prove that your idea is doable, you could start with a more forgiving language like Python. At this point, you don\u0026rsquo;t need any user interface, specific architecture, or design. None of the code will end up in the codebase anyway.\nWhen you verify that your vision is indeed possible to implement, you ditch everything and recode it properly using the lessons you\u0026rsquo;ve learned and tools that work on your target\u0026rsquo;s platform.\nOn the other spectrum, we have tracer bullets. Authors use the term tracer bullet development to visually illustrate the need for immediate feedback under actual conditions with a moving goal.\nIt\u0026rsquo;s an important distinction. With the tracer bullets approach, you don\u0026rsquo;t throw away any code when you finish. The code you write will end up in the final product. The only difference is that you focus on the key aspects of the system first.\nFor instance, imagine building a mobile application where users fill out a form. That submission hits our server to be processed later. A finished app requires a pleasant user interface with animations, validation on both the client and server-side, well-formatted responses, etc.\nWith the tracer bullet development approach, we would first focus on the most important things. We would start with a very basic form without any validation, and the submission would be printed to the console or saved in logs on the server-side without hitting the database.\nAt this point, we have a solid foundation. We\u0026rsquo;ve established the communication between the mobile app and our server. The code is covered by tests. Now, we have something to show to our clients or teammates. Later, we can expand and add more functionality with confidence.\nEstimating time Managers or clients often ask us to evaluate how long something will take. Estimating time is extremely difficult, especially when people expect us to provide a single number, like 12 days.\nIn the real world, people don\u0026rsquo;t estimate with single numbers. They use a range of scenarios.\nThere is a methodology that adopts this style of assessment. It\u0026rsquo;s called Program Evaluation Review Technique, or PERT.\nEvery PERT task has an optimistic, most likely, and pessimistic estimate. The tasks are arranged into a dependency network, and then you use some simple statistics to identify likely best and worst times for the overall project.\nWith this approach, you don\u0026rsquo;t specify one fixed number. It helps to account for different potential problems that we might encounter along the way.\nOf course, a single method won\u0026rsquo;t suddenly make estimating easy. That\u0026rsquo;s why it\u0026rsquo;s important to record our estimates. When we finish a project or an iteration, we can see how close we were. If the gap was significant, we should stop and think about a reason. With time and practice, we will give more accurate estimations.\nBe fluent with your tools If you recall yourself trying to learn how to drive a car, you might remember that you had to think about every action you took. Later, with more experience, controlling the car became automatic and instinctive.\nWe should aim for the same automation mechanisms when using our tools. If we don\u0026rsquo;t have to think about all the keyboard shortcuts and options while programming, our minds will have more capacity to think about the problem at hand.\nThe authors give us some tips about what it means to be fluent with our tools. You are fluent when you can:\n When editing text, move and make selections by character, word, line, and paragraph. When editing code, move by various syntactic units (matching delimiters, functions, modules, etc.). Reindent code following changes. Comment and uncomment blocks of code with a single command. Split the editor window into multiple panels and navigate between them. Navigate to a particular line number. Search for both strings and regular expressions. Temporarily create multiple cursors based on a selection or a pattern match, and edit the text at each in parallel. Run the current project’s tests.  Ideally, you can do all of this without using a mouse or a trackpad.\nDebug with confidence Debugging and finding errors is not always fun. There is no point in making it more problematic than it has to be. The authors give us some general steps that we can follow to make this process at least a bit more effortless for us.\nFirst, before you start debugging, you should adopt the right mindset. Turn off all defensive mechanisms that protect your ego. Also, don\u0026rsquo;t waste time thinking that this couldn\u0026rsquo;t happen or it was impossible. You are looking at the stack trace right now. It clearly did happen.\nThen, always begin with making a bug reproducible. If you can\u0026rsquo;t do it, you will never know if it\u0026rsquo;s fixed. Ideally, try to make it possible to reproduce the error with a single command or action.\nThe root of the problem may lie in the OS, the compiler, or a third-party library. But that should never be your first thought. Always assume that the bug exists in your code and start from there. Because even if it does lie in the library, you would still have to trace the problem in your code before submitting the bug report to the maintainers.\nLastly, make sure that whatever was the problem, you’ll know if it occurs again. If your tests pass with the bug in the code, you can\u0026rsquo;t trust them with catching the bug next time.\nWrite a test, see it fail, fix the bug, and sleep well knowing that you are covered.\nEngineering daybook Have you ever found yourself trying to remember how you solved a particular problem? You probably wished at that moment that you had written the solution and explanation somewhere. It would save you a lot of time and energy.\nThat\u0026rsquo;s why Andy and Dave recommend keeping an engineering daybook when working. It\u0026rsquo;s a kind of journal in which you record what you do, things you learned, sketches of ideas, notes from meetings, variable values when debugging, etc.\nThe daybook has many benefits:\n It\u0026rsquo;s more reliable than memory. It acts as a kind of rubber duck. It forces you to think about a problem before writing it down. It serves as a database of documented memories. You can look at it and think about the people you collaborated with, projects you worked on, and problems you faced.  The authors suggest sticking to a plain old pen and paper. However, I think it might make sense to use a digital version for one reason. It\u0026rsquo;s searchable, and you can categorize your notes more easily.\nDead programs don\u0026rsquo;t lie Programmers tend to take a defensive approach when programming. We try to catch or rescue all possible exceptions, check for nullability before using variables, verify that the lists passed as arguments are not empty, etc. We avoid crashes at all costs.\nThe problem with this approach is that the app or system we are working on might stop working silently on production without us having any way of detecting it.\nSure, we checked that the list we wanted to display on the screen wasn\u0026rsquo;t empty or null. There will be no exception thrown when we try to access it. But what will the user see? Most likely a blank screen. Our app will be in a state that it wasn\u0026rsquo;t designed for. At this point, it\u0026rsquo;s hard to tell why the list was empty. Did we forget to populate it? Did we receive corrupted data from the backend?\nIf our app gets in a weird state, it would be nice to know it. That\u0026rsquo;s why unhandled exceptions are not always such a bad thing. They are collected by your crash reporting tool and will help you find the root of the problem.\nAdditionally, allowing our program to continue after entering an inappropriate state might be disastrous. Anything it does from this point forward can introduce strange problems like inconsistent or corrupted data sent to our production database.\n A dead program does a lot less damage than a crippled one.\n I also recommend reading this article (and its comment section for contrasting opinions) about crashes in mobile apps.\nTake small steps It\u0026rsquo;s usually better to take small and deliberate steps. You then check for feedback and adjust before proceeding. Feedback can take many forms, for example, an MVP that you show to your client or unit tests that verify the correctness of your last code change.\nWe should avoid steps that are too big. They require an attempt to predict the future. No one can do that. You might want to think twice when you find yourself doing one of those things:\n Estimate completion dates months in advance. Guess users\u0026rsquo; future needs and preferences. Predict future tech trends and tools.  Around two decades ago, debates raged in online forums over questions like \u0026ldquo;Who would win the desktop GUI wars, Motif or OpenLook?\u0026rdquo;. Chances are, you\u0026rsquo;ve never heard of these technologies. Remember this story next time you see yourself fortune-telling.\nDecoupling We want our code to be as flexible as possible. Coupled code is hard to change. Modifications in one place can have secondary effects in other locations.\nThe authors present this snippet of code to demonstrate the problem:\nprivate fun applyDiscount(customer: Customer, orderId: Int, discount: Discount) { \tcustomer \t.orders \t.find(orderId) \t.getTotals() \t.applyDiscount(discount) } What we can see here is the so-called Train Wreck. This code is traversing five levels of abstraction, from customer to total amounts. Our top-level code has to know about each level\u0026rsquo;s internal implementation. It knows that the customer object exposes orders, that the orders have a find method, and that the order object has a totals object which contains information about discounts and grand totals.\nThere is a lot of coupling here. Imagine that someone decides that no order can have a discount of more than 50%. Where should we implement this change? You might think that it belongs to applyDiscount(). It\u0026rsquo;s true, but the problem is that there might be other places that modify the totals object besides this function. We would have to find all of them and adjust accordingly. That\u0026rsquo;s potentially a lot of work.\nSo, what\u0026rsquo;s the solution? Andy and Dave have a principle that they call:\n Tell, Don\u0026rsquo;t Ask.\n We shouldn\u0026rsquo;t ask about an object\u0026rsquo;s internal state and then modify it based on the information we receive. We should tell it to do what we need.\nWe could refactor the code above to something like this:\nprivate fun applyDiscount(customer: Customer, orderId: Int, discount: Discount) { \tcustomer \t.findOrder(orderId) \t.applyDiscount(discount) } With this change, our top-level code doesn\u0026rsquo;t have to know that the order class uses a separate object to store its totals and discounts. We also don\u0026rsquo;t fetch a list of orders from the customer and search for a specific one. We get the order that we want directly from the customer.\nRight now, we have only one place that manages discounts and all rules can be encapsulated there.\nFear of the blank page I\u0026rsquo;m sure we\u0026rsquo;ve all experienced this. We start working on a new feature or a completely new project. The cursor is blinking. The screen is empty and ready to be filled with code. For some reason, the experience is very intimidating. We put off making the initial commitment of starting.\nThe authors say the most likely reason we feel this way is that we are afraid of making a mistake. We fear the architecture we are implementing will not be flexible enough. We worry that the code will not be readable by other developers. We stress about introducing new bugs or problems. Potentially, we may think that the task is beyond our skills. We can\u0026rsquo;t see our way through to the end.\nAndy and Dave claim that they found a brain hack that seems to work in this kind of situation:\n Pretend that you are prototyping.\n Remember that prototypes get thrown away, even if they don\u0026rsquo;t fail. If your mind knows this, you are less likely to feel anxious. If anything goes wrong, you will stash all of it away. No problem. But what\u0026rsquo;s usually happening is this. After some time, you find that the code flies from your brain into the editor. The initial stress is gone. You start to see the bigger picture. You know how to proceed.\nTo make it even more clear to you, the authors suggest writing \u0026ldquo;I\u0026rsquo;m prototyping\u0026rdquo; on a sticky note and attaching it on the side of your screen.\nI tried this trick a couple of times and it worked for me. It helps with one of the hardest things - forcing yourself to start writing.\nDon\u0026rsquo;t program by coincidence When you use a technology you don\u0026rsquo;t understand, you program by coincidence. If you\u0026rsquo;re unsure why something works, you won\u0026rsquo;t know why it fails. Programming by coincidence is the opposite of programming deliberately.\n\u0026ldquo;It doesn\u0026rsquo;t work without it\u0026rdquo; is not a good reason to keep maintaining a specific portion of code. Unnecessary calls slow the program down or introduce bugs that are difficult to spot. What\u0026rsquo;s worse is that other developers won\u0026rsquo;t usually bother trying to mess with it to improve it. \u0026ldquo;If it works now, it\u0026rsquo;s better to leave it alone\u0026hellip;\u0026rdquo;\nWe all want to work with error-free code and catch all bugs as early in the development cycle as possible. To do that, we should always program deliberately. Make sure you have at least a basic understanding of all the libraries and tools you use in your application or system. Asks yourself questions - would I be able to explain this piece of code to a more junior programmer? If not, perhaps you are relying on coincidence.\nNext time something seems to work, but you don’t know why, make sure it isn’t just a coincidence. Don\u0026rsquo;t assume anything. Prove it.\nCode is a garden  A tourist visiting England’s Eton College asked the gardener how he got the lawns so perfect. “That’s easy,” he replied, “You just brush off the dew every morning, mow them every other day, and roll them once a week.”\n“Is that all?” asked the tourist. “Absolutely,” replied the gardener. “Do that for 500 years and you’ll have a nice lawn, too.”\n Code is not static. It constantly evolves. Inaccurately, some people associate software development with building construction. It implies that there is an architect that draws the initial blueprints. Then, contractors dig the foundation, build the superstructure and apply final touches. At this point, there is no easy way to change anything. The project is considered finished and the tenants move in.\nThe software doesn\u0026rsquo;t quite work that way. It\u0026rsquo;s more like a garden when things change all the time. You plant different things according to the initial plan and environment. After observing the typical weather conditions, you may move plantings to other places. Overgrown plants get split. You pull weeds and fertilize plantings. The health of the garden needs constant monitoring and adjustments.\nThe gardening metaphor is much closer to the realities of software development. Laws of physics don\u0026rsquo;t constrain code as they do with buildings.\nThis philosophy led to a discipline called Refactoring. Martin Fowler defines it as a \u0026ldquo;disciplined technique for restructuring an existing body of code, altering its internal structure without changing its external behavior.\u0026rdquo; This technique inlines with the idea that code requires constant improvement and refinement.\nTests aren\u0026rsquo;t only about finding errors When we ask developers why they write tests, most of them would say \u0026ldquo;to make sure the code works\u0026rdquo;. It\u0026rsquo;s a perfectly valid reason. But Andy and Dave argue that there is much more to tests than that.\nThey believe that the sole act of thinking about tests while coding is the main benefit of tests.\nConsider the following example. You are working on a class that is supposed to fetch tomorrow\u0026rsquo;s lottery numbers. That\u0026rsquo;s the code you have written so far:\nclass FetchTomorrowsLotteryNumbersUseCase {  private val service = LotteryNumbersService()   operator fun invoke() = service.fetch() } The above code works completely fine when you run it. Now what\u0026rsquo;s left is to wait for tomorrow and hope that this service is reliable.\nBut because you are constantly thinking about tests, you start wondering how to write tests for the given code. It would be reasonable to use some test data and not rely on the remote service. The current implementation makes it problematic because we don\u0026rsquo;t control how this class interacts with data. The easiest way to make it possible during tests is to pass the service as a parameter. The code could now look like this:\nclass FetchTomorrowsLotteryNumbersUseCase(  private val service: LotteryNumbersService ) {  operator fun invoke() = service.fetch() } Thinking about testing made us reduce coupling in the code (by passing in a service that we can control from the outside) and increase flexibility. When we think about writing tests for the code we are working on, we imagine ourselves as clients of the code, not its authors.\nBe proud of your work The authors say that pragmatic programmers should be proud to sign their work just like artisans of an earlier age. When we are accountable for a piece of code, we aspire to do a job we can be proud of.\nThe opposite of it is anonymity. It provides room for mistakes, sloppiness, and bad code, especially on large projects. It creates an environment where no one feels any responsibility.\nWe should aim to associate our signatures with an indication of high quality. When other developers see our code, they should expect it to be solid, well-written, thoroughly tested, and documented.\nSummary Andy and Dave end the book by concluding that we have a lot of power (and responsibility) as programmers. Systems and devices that we build can shape the lives of millions. How often do we stop and think about this?\nWe should do our best to protect the users from any potential harm. If we are involved in a project that requires us to do something against our beliefs or values, we shouldn\u0026rsquo;t be afraid to say \u0026ldquo;no\u0026rdquo;. Would I enjoy using this software as a user? Would I be comfortable with my sensitive data being shared with this company? Do I know something important that users don\u0026rsquo;t?\nWe are building the future for ourselves and our descendants. Let\u0026rsquo;s envision the future everyone would like to live in and have the courage to work on it every day.\n","permalink":"https://arkadiuszchmura.com/posts/my-key-takeaways-from-the-pragmatic-programmer/","summary":"In this blog post, I list things that resonate with me most after reading this book.","title":"My key takeaways from The Pragmatic Programmer"},{"content":"Introduction When creating a widget for your Android app, one of the components that you need to define is a class that extends AppWidgetProvider. Through it, you will receive broadcasts when the widget is updated, enabled, disabled, deleted, resized, etc. You can then act accordingly and, for example, refresh the widget\u0026rsquo;s view to display the newest data.\nI implemented a widget in one of my apps following the steps mentioned in the documentation and everything was working just fine.\nAt least until one day. After noticing that my app is getting bigger, I decided to change the structure of my app a little to package classes by features rather than by layers.\nWhen I changed the package name of my class extending AppWidgetProvider from\ncom.arkadiusz.Provider.MyAppWidgetProvider to\ncom.arkadiusz.data.providers.MyAppWidgetProvider and relaunched the app, all app\u0026rsquo;s widgets disappeared from my home screen.\nI can consider myself lucky for noticing this before releasing the next version of the app and causing this problem for all users.\nIt is quite strange that changing a package name of one class can produce such a radical effect so let\u0026rsquo;s dive into the Android source code and find out why this is happening.\nBehind the scenes In Android, a system service responsible for managing widgets across the entire OS is called AppWidgetService. This is a component that knows, among other things, how and when to update your widgets (based, for example, on the information that you specify in your AppWidgetProviderInfo XML).\nInternally, some of the variables that it holds are as follows:\nprivate final ArrayList\u0026lt;Widget\u0026gt; mWidgets = new ArrayList\u0026lt;\u0026gt;(); private final ArrayList\u0026lt;Host\u0026gt; mHosts = new ArrayList\u0026lt;\u0026gt;(); private final ArrayList\u0026lt;Provider\u0026gt; mProviders = new ArrayList\u0026lt;\u0026gt;();  mWidgets stores references to all widgets that are placed within all hosts. mHosts stores references to all AppWidgetHosts, which are components designed to be used by applications that want to embed widgets in their UI (mostly home screen applications). They provide interaction with the AppWidget service. mProviders stores references to all AppWidgetProviders that were registered by currently installed apps. Each Provider object is identified by a ComponentName (which stores two pieces of information - package name and the class name). It also keeps references to all widgets that it is responsible for.  The AppWidget service also listens for different broadcasts related to application packages (like Intent.ACTION_PACKAGE_ADDED or Intent.ACTION_PACKAGE_REMOVED). It does that to keep its ArrayLists up to date. For example, when a user deletes an app from their device, the service can remove every widget and provider associated with this app because they are no longer needed.\nI mentioned earlier that the service identifies each provider by its ComponentName. Well, if we decide to change the provider\u0026rsquo;s package name or class name, the new ComponentName is going to be different. This is the root of the problem.\nHere is what happens when you modify your provider\u0026rsquo;s package name or class name and then update your app:\n The AppWidget service is notified about an application package update via a broadcast. It reads the app\u0026rsquo;s manifest file and finds a new provider that it hasn\u0026rsquo;t seen before (it has a unique ComponentName). It registers and stores it inside the mProviders variable. Then, the service notices that it keeps a reference to a provider that is no longer used (your previous provider). There is no manifest file that declares it so the service decides that it is safe to remove it entirely. As part of the provider\u0026rsquo;s removal process, every widget associated with that provider is removed as well. You end up with empty widgets on the home screen that are no longer referenced by any component and cannot be updated. The only way to get them to work again is to add them to the launcher anew.  I am not alone Interestingly, developers working on the Firefox app faced the same problem. If you look at the source code of their class extending AppWidgetProvider, you will find a comment at the top warning against modifying the package name or the class name:\nclass SearchWidgetProvider : AppWidgetProvider() { \t// Implementation note: \t// This class name (SearchWidgetProvider) and package name (org.mozilla.gecko.search) should \t// not be changed because otherwise this widget will disappear from the home screen of the user. \t// The existing name replicates the name and package we used in Fennec. Solution? Unfortunately, there is currently no way to solve this problem as the code responsible for this behavior lies beyond our control. The only thing you can do is to make sure not to modify anything related to your widget provider after releasing your app if you don\u0026rsquo;t want your users to lose their existing widgets.\nHonestly, in most cases, it won\u0026rsquo;t be a huge deal. Even though users would have to place those widgets again on their home screen, everything will continue to work as previously. However, if the configuration of widgets in your app is complicated and time-consuming, this can cause a lot of frustration.\nSummary Once you implement widgets in your app and release it, do not change the package name or class name of your class extending AppWidgetProvider. It will wipe out all of your user\u0026rsquo;s existing widgets and possibly bring a flood of 1-star reviews for your app.\n","permalink":"https://arkadiuszchmura.com/posts/do-not-change-the-package-name-or-class-name-of-your-app-widget-provider/","summary":"If you do this, widgets that were placed on the home screen by your users will simply disappear.","title":"Do not change the package name or class name of your AppWidgetProvider"},{"content":"Introduction Users of one of my apps heavily rely on widgets. They place them on their home screens to count days to specific events. It is therefore important to keep those widgets up to date and refresh them at least once per day.\nNot long ago, I have been getting some emails (as well as 1-star reviews) from my users reporting that their widgets are not being updated properly on their phones.\nThe Android documentation says that to update a widget periodically at some interval, you can specify android:updatePeriodMillis attribute on the widget\u0026rsquo;s metadata - AppWidgetProviderInfo XML.\nUnfortunately, despite setting this attribute in my app, widgets were still not updated reliably on some users\u0026rsquo; phones.\nThe problem might be that some vendors introduce their own set of rules that restrict background processing and ignore this attribute altogether under some circumstances to artificially save some battery life.\nSolution Since I could not count on this attribute alone, I needed another solution to support it. Luckily, Android Jetpack has a component that could help me periodically update widgets - WorkManager. As of writing this article, it is the primary recommended API for background processing.\nQuoting the documentation, WorkManager handles three types of persistent work:\n Immediate: Tasks that must begin immediately and complete soon. May be expedited. Long Running: Tasks which might run for longer, potentially longer than 10 minutes. Deferrable: Scheduled tasks that start at a later time and can run periodically.  Support for the third type of work perfectly matched my use case so I decided to give it a try.\nHere are the steps I took to import and setup WorkManager in my app:\n1. Import the library into your Android project (using the newest version):\ndependencies {  val work_version = \u0026#34;2.7.1\u0026#34;   // Java only  implementation(\u0026#34;androidx.work:work-runtime:$work_version\u0026#34;)   // Kotlin + coroutines  implementation(\u0026#34;androidx.work:work-runtime-ktx:$work_version\u0026#34;) } 2. Define the work\nHere we specify what our work actually does. We do this by creating our own implementation of the Worker class and overriding the doWork() method. This method runs asynchronously on a background thread provided by WorkManager.\nIn this case, we simply grab a list of relevant widget ids and notify the AppWidgetManager to perform an update on them by sending an Intent.\nclass WidgetUpdateWorker(  private val appContext: Context,  workerParams: WorkerParameters ) : Worker(appContext, workerParams) {   override fun doWork(): Result {  // This line might be different in your case  val widgetIds = DatabaseRepository.getWidgetIds()   val intent = Intent(  AppWidgetManager.ACTION_APPWIDGET_UPDATE, null, appContext,  MyAppWidgetProvider::class.java  )  intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, widgetIds)  appContext.sendBroadcast(intent)   return Result.success()  } } One thing to note here - MyAppWidgetProvider is a subclass of the AppWidgetProvider that is needed when creating a widget.\n3. Define WorkRequest and schedule it\nNow that we defined our work, it is necessary to specify how and when that work should be run. We do this by defining a WorkRequest. In our case, we simply want to run the work periodically at some interval.\nval widgetUpdateRequest = PeriodicWorkRequestBuilder\u0026lt;WidgetUpdateWorker\u0026gt;(  4, TimeUnit.HOURS ).build() Finally, we can put everything together and schedule our work. The code below could be placed in the Application.onCreate() or in your main activity\u0026rsquo;s onCreate().\nWorkManager.getInstance(this).enqueueUniquePeriodicWork(  \u0026#34;widgetUpdateWork\u0026#34;,  ExistingPeriodicWorkPolicy.KEEP,  widgetUpdateRequest ) The first parameter - \u0026quot;widgetUpdateWork\u0026quot; is a unique name that identifies the work.\nThe ExistingPeriodicWorkPolicy.KEEP flag tells the WorkManager to keep using the existing work if there is one already scheduled with the same name.\nThe third parameter is a WorkRequest that we\u0026rsquo;ve just defined.\nAnd that\u0026rsquo;s it! The work is now scheduled and our widgets are going to be periodically updated.\nAs a side note, there are many benefits to using the WorkManager versus relying on the standard way of updating the widgets. Here are some of them:\n Once you specify the android:updatePeriodMillis attribute, it is fixed and cannot be changed in any other way than updating the app with a new value. On the other hand, you can let your users decide how often widgets should be updated with WorkManager and change this value at runtime. WorkManager automatically ensures that the scheduled tasks are going to finish even when the OS decides to kill the app to reclaim some memory. Internally, WorkManager uses JobScheduler (on API 23+) or a combination of AlarmManager and BroadcastReceiver on older versions. This makes it less likely to be restricted by some vendors.  After introducing WorkManager, the number of emails from my users about their widgets not being updated properly dropped significantly.\nSummary To summarize, here are the key points from this post:\n Some vendors restrict background processing in order to save some battery life. Because of this, the standard way of updating widgets (with the android:updatePeriodMillis attribute) doesn\u0026rsquo;t always work. To solve this problem, we can introduce WorkManager that will periodically update widgets and make sure that they are up to date.  ","permalink":"https://arkadiuszchmura.com/posts/how-to-reliably-update-widgets-on-android/","summary":"The default solution with android:updatePeriodMillis doesn\u0026rsquo;t always work.","title":"How to reliably update widgets on Android"},{"content":"Introduction In December 2021 I was working on a problem from the Advent of Code 2021 that required getting all elements from two collections that were contained in both of them. In Kotlin, there is an extension function for that use case on Iterable called intersect.\nIn my case, the first collection was a regular List and the second one was a Set.\nThe code that I eventually used was analogical to this one:\nval x = (1..1_000_000).toList() val y = (1..100_000).toSet()  x intersect y However, when refactoring the code, I incidentally changed the order of the operands and the last line became y intersect x.\nGiven the fact it was the only modification to the code I made, I was genuinely surprised to find that my program now runs a couple of times slower.\nThat led me to run some experiments to verify whether this seemingly irrelevant change really affects the performance such drastically or the reason was to be found somewhere else.\nThe experiment I decided to use the same code introduced above and measure the execution time separately for both variants:\n For x intersect y. For y intersect x.  For each variant, the experiment was repeated 20 times on my machine (MacBook Pro 13-inch, early 2015) and the average time was obtained.\nFull code for the experiment:\nval results = mutableListOf\u0026lt;Long\u0026gt;()  repeat(20) {  measureTime {  val x = (1..1_000_000).toList()  val y = (1..100_000).toSet()   x intersect y // or y intersect x  }.inWholeMilliseconds.also { results.add(it) } }  print(results.average()) Here are the results:\n   Variant Time     x intersect y 224 ms   y intersect x 4793 ms    As you can see, the outcome is quite surprising. What\u0026rsquo;s more, the bigger the y collection, the greater the time difference between those two variants.\nFindings Overall, as I dig deeper into the topic (including the source code of the intersect function), I realized that the problem is not the order of the operands itself, but rather the fact that the second operand in the slower variant was not of type Set.\nMoreover, this problem only exists starting with Kotlin 1.6. In prior versions, both of those tested variants (x intersect y and y intersect x) would yield the same results. That\u0026rsquo;s why it might be worth providing a little story behind this issue:\nBefore Kotlin 1.6 In many cases, when running some of the Collection operations (such as aforementioned intersect, minus, removeAll or retainAll), Kotlin tried to optimize them by converting their second operands to a Set under the hood.\nWhy would it do that?\nLet\u0026rsquo;s consider the minus operation. It returns a list consisting of elements from the first collection that are not present in the second collection. It does that by filtering the first collection to keep only the items that are not in the second collection. But how does it know that a specific item is not present in that collection? By calling its contains method.\nTypically, the complexity of checking for the existence of an item in a regular list or array is linear. We have to go through each item one by one. On the other hand, that complexity is reduced to a constant time for sets. To check whether an item is present in the set, it is enough to compute its hash code.\nFor that specific reason, Kotlin tried to introduce this optimization any time it could to improve the performance. But it was not possible in all cases.\nThe problem was that a collection could override its contains method causing some unexpected behavior down the road.\nFor instance, imagine we pass a collection with overridden contains method that we count on (for example, an IdentitySet). Kotlin then converts it under the hood to a different type - a HashSet. With this change, we can no longer rely on our custom contains implementation because the initial collection is now of another type. This could lead to some errors that are difficult to debug.\nThat is why the optimization was applied only in specific cases:\n When the operand was not implementing a Collection interface (meaning it could not override its contains method). When the operand is a known implementation of Collection that doesn\u0026rsquo;t override contains (currently only kotlin.collections.ArrayList)  However, as it turned out, this optimization was quite problematic for a few reasons:\n The code responsible for deciding whether to convert the second operand to a Set was quite difficult to read. Therefore, it was not obvious at the first glance if it was going to be converted or not. Sometimes, we might not be aware of the actual implementation of a specific collection - it could be \u0026ldquo;hidden\u0026rdquo; behind some interface. So, we cannot easily deduce whether it would get converted or not. There were some problems (described here) leading to incorrect results when any element changed its hashCode value after being placed to the converted set.  Since Kotlin 1.6 For the reasons mentioned above, the Kotlin team decided to remove this optimization entirely. Now, the second operand will never be converted to a Set. At most, it will be converted to a List if the operand is not implementing the Collection interface.\nFor a full list of affected API, see this link.\nBecause this decision could potentially cause performance degradation in some cases, an inspection was added to inform about this issue offering an option to manually convert the second operand to a Set.\n Inspection in IntelliJ IDEA informing about a potential performance issue.(The argument can be converted to \u0026lsquo;Set\u0026rsquo; to improve performance)\n  For now, it is possible to enable this optimization back on the JVM with a system property (kotlin.collections.convert_arg_to_set_in_removeAll). This will give more time to the developers that were previously relying on this feature to migrate the affected code.\nAlthough, it is worth mentioning that the possibility of enabling the optimization back is planned to be removed in Kotlin 1.7. The same thing is going to happen to the inspection. It will be turned off by default with the next major release. Yet you will be able to turn it on again by going to Preferences -\u0026gt; Editor -\u0026gt; Inspections -\u0026gt; Kotlin -\u0026gt; Other problems.\nThey give the following explanation for their decision:\n However, we expect this inspection to be quite annoying in places where such time complexity does not that matter, so we plan to disabling it by default in the next version of Kotlin and leaving only an intention.\n Summary To summarize, here are the key points from this post:\n Since Kotlin 1.6, the second operands of some Kotlin Collection operations will no longer be converted to a Set under the hood. That may have some performance implications, so an inspection was added to inform you about this issue whenever applicable. However, the inspection will be turned off by default with the next major release of Kotlin (1.7). You might want to consider turning it on again if you think your codebase might benefit from having it.  ","permalink":"https://arkadiuszchmura.com/posts/beware-of-the-order-of-operands-in-some-kotlin-collection-operations/","summary":"The order of operands can drastically affect the performance of your code.","title":"Beware of the order of operands in some Kotlin Collection operations"}]