[{"content":"Introduction Users of one of my apps heavily rely on widgets. They place them on their home screens to count days to specific events. It is therefore important to keep those widgets up to date and refresh them at least once per day.\nNot long ago, I have been getting some emails (as well as 1-star reviews) from my users reporting that their widgets are not being updated properly on their phones.\nThe Android documentation says that to update a widget periodically at some interval, you can specify android:updatePeriodMillis attribute on the widget\u0026rsquo;s metadata - AppWigetProviderInfo XML.\nUnfortunately, despite setting this attribute in my app, widgets were still not updated reliably on some users' phones.\nThe problem might be that some vendors introduce their own set of rules that restrict background processing and ignore this attribute altogether under some circumstances to artificially save some battery life.\nSolution Since I could not count on this attribute alone, I needed another solution to support it. Luckily, Android Jetpack has a component that could help me periodically update widgets - WorkManager. As of writing this article, it is the primary recommended API for background processing.\nQuoting the documentation, WorkManager handles three types of persistent work:\n Immediate: Tasks that must begin immediately and complete soon. May be expedited. Long Running: Tasks which might run for longer, potentially longer than 10 minutes. Deferrable: Scheduled tasks that start at a later time and can run periodically.  Support for the third type of work perfectly matched my use case so I decided to give it a try.\nHere are the steps I took to import and setup WorkManager in my app:\n1. Import the library into your Android project (using the newest version):\ndependencies { val work_version = \u0026#34;2.7.1\u0026#34; // Java only  implementation(\u0026#34;androidx.work:work-runtime:$work_version\u0026#34;) // Kotlin + coroutines  implementation(\u0026#34;androidx.work:work-runtime-ktx:$work_version\u0026#34;) } 2. Define the work\nHere we specify what our work actually does. We do this by creating our own implementation of the Worker class and overriding the doWork() method. This method runs asynchronously on a background thread provided by WorkManager.\nIn this case, we simply grab a list of relevant widget ids and notify the AppWidgetManager to perform an update on them by sending an Intent.\nclass WidgetUpdateWorker( private val appContext: Context, workerParams: WorkerParameters ) : Worker(appContext, workerParams) { override fun doWork(): Result { // This line might be different in your case  val widgetIds = DatabaseRepository.getWidgetIds() val intent = Intent( AppWidgetManager.ACTION_APPWIDGET_UPDATE, null, appContext, MyAppWidgetProvider::class.java ) intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, widgetIds) appContext.sendBroadcast(intent) return Result.success() } } One thing to note here - MyAppWidgetProvider is a subclass of the AppWidgetProvider that is needed when creating a widget.\n3. Define WorkRequest and schedule it\nNow that we defined our work, it is necessary to specify how and when that work should be run. We do this by defining a WorkRequest. In our case, we simply want to run the work periodically at some interval.\nval widgetUpdateRequest = PeriodicWorkRequestBuilder\u0026lt;WidgetUpdateWorker\u0026gt;( 4, TimeUnit.HOURS ).build() Finally, we can put everything together and schedule our work. The code below could be placed in the Application.onCreate() or in your main activity\u0026rsquo;s onCreate().\nWorkManager.getInstance(this).enqueueUniquePeriodicWork( \u0026#34;widgetUpdateWork\u0026#34;, ExistingPeriodicWorkPolicy.KEEP, widgetUpdateRequest ) The first parameter - \u0026quot;widgetUpdateWork\u0026quot; is a unique name that identifies the work.\nThe ExistingPeriodicWorkPolicy.KEEP flag tells the WorkManager to keep using the existing work if there is one already scheduled with the same name.\nThe third parameter is a WorkRequest that we\u0026rsquo;ve just defined.\nAnd that\u0026rsquo;s it! The work is now scheduled and our widgets are going to be periodically updated.\nAs a side note, there are many benefits to using the WorkManager versus relying on the standard way of updating the widgets. Here are some of them:\n Once you specify the android:updatePeriodMillis attribute, it is fixed and cannot be changed in any other way than updating the app with a new value. On the other hand, you can let your users decide how often widgets should be updated with WorkManager and change this value at runtime. WorkManager automatically ensures that the scheduled tasks are going to finish even when the OS decides to kill the app to reclaim some memory. Internally, WorkManager uses JobScheduler (on API 23+) or a combination of AlarmManager and BroadcastReceiver on older versions. This makes it less likely to be restricted by some vendors.  After introducing WorkManager, the number of emails from my users about their widgets not being updated properly dropped significantly.\nConclusion To summarize, here are the key points from this post:\n Some vendors restrict background processing in order to save some battery life. Because of this, the standard way of updating widgets (with the android:updatePeriodMillis attribute) doesn\u0026rsquo;t always work. To solve this problem, we can introduce WorkManager that will periodically update widgets and make sure that they are up to date.  ","permalink":"https://arkadiuszchmura.com/posts/how-to-reliably-update-widgets-on-android/","summary":"The default solution with android:updatePeriodMillis doesn\u0026rsquo;t always work.","title":"How to reliably update widgets on Android"},{"content":"Introduction In December 2021 I was working on a problem from the Advent of Code 2021 that required getting all elements from two collections that were contained in both of them. In Kotlin, there is an extension function for that use case on Iterable called intersect.\nIn my case, the first collection was a regular List and the second one was a Set.\nThe code that I eventually used was analogical to this one:\nval x = (1..1_000_000).toList() val y = (1..100_000).toSet() x intersect y However, when refactoring the code, I incidentally changed the order of the operands and the last line became y intersect x.\nGiven the fact it was the only modification to the code I made, I was genuinely surprised to find that my program now runs a couple of times slower.\nThat led me to run some experiments to verify whether this seemingly irrelevant change really affects the performance such drastically or the reason was to be found somewhere else.\nThe experiment I decided to use the same code introduced above and measure the execution time separately for both variants:\n For x intersect y. For y intersect x.  For each variant, the experiment was repeated 20 times on my machine (MacBook Pro 13-inch, early 2015) and the average time was obtained.\nFull code for the experiment:\nval results = mutableListOf\u0026lt;Long\u0026gt;() repeat(20) { measureTime { val x = (1..1_000_000).toList() val y = (1..100_000).toSet() x intersect y // or y intersect x  }.inWholeMilliseconds.also { results.add(it) } } print(results.average()) Here are the results:\n   Variant Time     x intersect y 224 ms   y intersect x 4793 ms    As you can see, the outcome is quite surprising. What\u0026rsquo;s more, the bigger the y collection, the greater the time difference between those two variants.\nFindings Overall, as I dig deeper into the topic (including the source code of the intersect function), I realized that the problem is not the order of the operands itself, but rather the fact that the second operand in the slower variant was not of type Set.\nMoreover, this problem only exists starting with Kotlin 1.6. In prior versions, both of those tested variants (x intersect y and y intersect x) would yield the same results. That\u0026rsquo;s why it might be worth providing a little story behind this issue:\nBefore Kotlin 1.6 In many cases, when running some of the Collection operations (such as aforementioned intersect, minus, removeAll or retainAll), Kotlin tried to optimize them by converting their second operands to a Set under the hood.\nWhy would it do that?\nLet\u0026rsquo;s consider the minus operation. It returns a list consisting of elements from the first collection that are not present in the second collection. It does that by filtering the first collection to keep only the items that are not in the second collection. But how does it know that a specific item is not present in that collection? By calling its contains method.\nTypically, the complexity of checking for the existence of an item in a regular list or array is linear. We have to go through each item one by one. On the other hand, that complexity is reduced to a constant time for sets. To check whether an item is present in the set, it is enough to compute its hash code.\nFor that specific reason, Kotlin tried to introduce this optimization any time it could to improve the performance. But it was not possible in all cases.\nThe problem was that a collection could override its contains method causing some unexpected behavior down the road.\nFor instance, imagine we pass a collection with overridden contains method that we count on (for example, an IdentitySet). Kotlin then converts it under the hood to a different type - a HashSet. With this change, we can no longer rely on our custom contains implementation because the initial collection is now of another type. This could lead to some errors that are difficult to debug.\nThat is why the optimization was applied only in specific cases:\n When the operand was not implementing a Collection interface (meaning it could not override its contains method). When the operand is a known implementation of Collection that doesn\u0026rsquo;t override contains (currently only kotlin.collections.ArrayList)  However, as it turned out, this optimization was quite problematic for a few reasons:\n The code responsible for deciding whether to convert the second operand to a Set was quite difficult to read. Therefore, it was not obvious at the first glance if it was going to be converted or not. Sometimes, we might not be aware of the actual implementation of a specific collection - it could be \u0026ldquo;hidden\u0026rdquo; behind some interface. So, we cannot easily deduce whether it would get converted or not. There were some problems (described here) leading to incorrect results when any element changed its hashCode value after being placed to the converted set.  Since Kotlin 1.6 For the reasons mentioned above, the Kotlin team decided to remove this optimization entirely. Now, the second operand will never be converted to a Set. At most, it will be converted to a List if the operand is not implementing the Collection interface.\nFor a full list of affected API, see this link.\nBecause this decision could potentially cause performance degradation in some cases, an inspection was added to inform about this issue offering an option to manually convert the second operand to a Set.\n Inspection in IntelliJ IDEA informing about a potential performance issue.(The argument can be converted to \u0026lsquo;Set\u0026rsquo; to improve performance)\n  For now, it is possible to enable this optimization back on the JVM with a system property (kotlin.collections.convert_arg_to_set_in_removeAll). This will give more time to the developers that were previously relying on this feature to migrate the affected code.\nAlthough, it is worth mentioning that the possibility of enabling the optimization back is planned to be removed in Kotlin 1.7. The same thing is going to happen to the inspection. It will be turned off by default with the next major release. Yet you will be able to turn it on again by going to Preferences -\u0026gt; Editor -\u0026gt; Inspections -\u0026gt; Kotlin -\u0026gt; Other problems.\nThey give the following explanation for their decision:\n However, we expect this inspection to be quite annoying in places where such time complexity does not that matter, so we plan to disabling it by default in the next version of Kotlin and leaving only an intention.\n Conclusion To summarize, here are the key points from this post:\n Since Kotlin 1.6, the second operands of some Kotlin Collection operations will no longer be converted to a Set under the hood. That may have some performance implications, so an inspection was added to inform you about this issue whenever applicable. However, the inspection will be turned off by default with the next major release of Kotlin (1.7). You might want to consider turning it on again if you think your codebase might benefit from having it.  ","permalink":"https://arkadiuszchmura.com/posts/beware-of-the-order-of-operands-in-some-kotlin-collection-operations/","summary":"The order of operands can drastically affect the performance of your code.","title":"Beware of the order of operands in some Kotlin Collection operations"}]