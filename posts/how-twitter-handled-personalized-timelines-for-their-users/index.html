<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>How Twitter handled personalized timelines for their users | Arkadiusz Chmura</title><meta name=keywords content><meta name=description content="The approach described here might be useful to you if your application has some sort of a personalized feed for each user."><meta name=author content><link rel=canonical href=https://arkadiuszchmura.com/posts/how-twitter-handled-personalized-timelines-for-their-users/><link crossorigin=anonymous href=/assets/css/stylesheet.min.9ba27e3c8c2747e1cde460076c0ca4266a90ef93999b5f361979f681b9f778a6.css integrity="sha256-m6J+PIwnR+HN5GAHbAykJmqQ75OZm182GXn2gbn3eKY=" rel="preload stylesheet" as=style><link rel=icon href=https://arkadiuszchmura.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://arkadiuszchmura.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://arkadiuszchmura.com/favicon-32x32.png><link rel=apple-touch-icon href=https://arkadiuszchmura.com/apple-touch-icon.png><link rel=mask-icon href=https://arkadiuszchmura.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.104.2"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="How Twitter handled personalized timelines for their users"><meta property="og:description" content="The approach described here might be useful to you if your application has some sort of a personalized feed for each user."><meta property="og:type" content="article"><meta property="og:url" content="https://arkadiuszchmura.com/posts/how-twitter-handled-personalized-timelines-for-their-users/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-06-28T00:00:00+00:00"><meta property="article:modified_time" content="2022-06-28T00:00:00+00:00"><meta property="og:site_name" content="Arkadiusz Chmura"><meta name=twitter:card content="summary"><meta name=twitter:title content="How Twitter handled personalized timelines for their users"><meta name=twitter:description content="The approach described here might be useful to you if your application has some sort of a personalized feed for each user."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://arkadiuszchmura.com/posts/"},{"@type":"ListItem","position":2,"name":"How Twitter handled personalized timelines for their users","item":"https://arkadiuszchmura.com/posts/how-twitter-handled-personalized-timelines-for-their-users/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"How Twitter handled personalized timelines for their users","name":"How Twitter handled personalized timelines for their users","description":"The approach described here might be useful to you if your application has some sort of a personalized feed for each user.","keywords":[],"articleBody":"Introduction In this post, I would like to write about an interesting concept I learned while reading Designing Data-Intensive Applications by Martin Kleppmann. More specifically, it’s a story of how Twitter handled some of its scalability challenges related to users’ personalized timelines. If you work on an application with some sort of a personalized feed/timeline for each user, the idea introduced here might help you improve the performance or give you inspiration for your next app’s architecture.\nScaling timelines In November 2012, at a conference in San Francisco, Raffi Krikorian published some data about two of Twitter’s main operations:\nPost tweet - a user can post a new tweet to their followers (4,6k requests/sec on average, over 12k requests/sec at peak). Home timeline - a user can view tweets posted by the people they follow (300k requests/sec). With modern databases, handling 12,000 write requests is achievable fairly easily. But at Twitter, the challenge came not with the volume, but due to so-called fan-out. In transaction processing systems, this term is used to describe the number of requests to other services that need to be made to serve one incoming request. On Twitter, each user follows many people and each user is followed by many people. This means that when a new tweet is published, it needs to be delivered to all of the author’s followers. In some cases (e.g. celebrities with many followers), there might be a lot of work to do.\nOn a high level, there are two ways of implementing the two operations mentioned above. Let’s examine both of them.\nTraditional approach with relational schema This is probably the first approach that comes to most developers’ minds. The idea is relatively simple. We need some kind of storage for all posted tweets. When a new tweet is posted, it’s simply inserted into this global collection of tweets. When a user opens the website and requests their home timeline, all the tweets from all the people they follow are merged and served on demand. In a traditional relational database, you might have three tables to handle this scenario: users, tweets, and follows.\nusers table id first_name last_name username 21 Arkadiusz Chmura ClouddJr tweets table id user_id content created_at 14 21 Hello World! 2022-03-26 17:46:11 follows table follower_id followee_id 19212 21 Then, to get all the relevant tweets to assemble a user’s timeline, the SQL query could look like this:\nSELECT tweets.*, users.* FROM tweets JOIN users ON tweets.user_id = users.id JOIN follows ON follows.followee_id = users.id WHERE follows.follower_id = CURRENT_USER The biggest problem here is that we have to execute the above query every time we want to display a timeline for any user. It’s not hard to imagine the huge amount of work required when there are a lot of users on the platform with a substantial number of people they follow frequently accessing the website.\nThe first version of Twitter used this approach, but the system struggled to keep up with the load of home timeline queries. The number of users on the platform kept growing, so they had to introduce another solution.\nMaintaining a cache for individual timelines Here, the basic idea is that we prepare, or cache, each user’s home timeline ahead of time so that when it’s requested, no additional work is required. When a user posts a tweet, besides being stored in a table, it’s immediately inserted into timeline caches for all of their followers. Thanks to this, reading a timeline is very cheap, because it has already been computed - it’s enough to just read from the cache. There is no need for any other expensive database operations. This concept is visualized in the image below.\nTwitter’s data pipeline for delivering tweets to followers (2012)\nWhen it comes to actual tools that you could use to implement the timeline caching mechanism, a great option would be a very popular, open-source, in-memory data store called Redis.\nHowever, while reading all relevant tweets for each user is very cheap right now, there is one downside of this approach. Posting a tweet now requires a lot of additional work. Besides storing it in a table, it has to be inserted into many other caches. The average number of followers per user is 75, which means 4,6k new tweets per second becomes 345k writes per second to the home timeline caches (4,6k * 75).\nBut the average is affected mainly by users with many followers (there are some with more than 30 million). The majority of users have much fewer followers. This means that the extra work required for the fan-out when posting a new tweet is only noticeable for that small number of users with a very large number of followers.\nFor this reason, Twitter moved to a hybrid approach to take the best of both worlds. Tweets from “regular” users continue to be fanned-out to timeline caches, as illustrated above, while tweets from celebrities are excepted from that process. When a home timeline is requested, tweets from celebrities are fetched separately from the database and merged with what’s inside the user’s cache.\nSummary If you found this story interesting, you might enjoy reading the book it was mentioned in - Designing Data-Intensive Applications. It’s a good combination of the theory behind many enterprise-level tools and practical engineering. It compares many tools and approaches, including their strengths and weaknesses, to make it easier for us to decide what’s best for our applications.\n","wordCount":"907","inLanguage":"en","datePublished":"2022-06-28T00:00:00Z","dateModified":"2022-06-28T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://arkadiuszchmura.com/posts/how-twitter-handled-personalized-timelines-for-their-users/"},"publisher":{"@type":"Organization","name":"Arkadiusz Chmura","logo":{"@type":"ImageObject","url":"https://arkadiuszchmura.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://arkadiuszchmura.com/ accesskey=h title="Arkadiusz Chmura (Alt + H)">Arkadiusz Chmura</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://arkadiuszchmura.com/archive title=Archive><span>Archive</span></a></li><li><a href=https://arkadiuszchmura.com/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://arkadiuszchmura.com/>Home</a>&nbsp;»&nbsp;<a href=https://arkadiuszchmura.com/posts/>Posts</a></div><h1 class=post-title>How Twitter handled personalized timelines for their users</h1><div class=post-meta><span title='2022-06-28 00:00:00 +0000 UTC'>June 28, 2022</span>&nbsp;·&nbsp;5 min</div></header><div class=post-content><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>In this post, I would like to write about an interesting concept I learned while reading <a href=https://dataintensive.net/>Designing Data-Intensive Applications</a> by Martin Kleppmann. More specifically, it&rsquo;s a story of how Twitter handled some of its scalability challenges related to users&rsquo; personalized timelines. If you work on an application with some sort of a personalized feed/timeline for each user, the idea introduced here might help you improve the performance or give you inspiration for your next app&rsquo;s architecture.</p><h2 id=scaling-timelines>Scaling timelines<a hidden class=anchor aria-hidden=true href=#scaling-timelines>#</a></h2><p>In November 2012, at a conference in San Francisco, Raffi Krikorian published some data about two of Twitter&rsquo;s main operations:</p><ul><li><strong>Post tweet</strong> - a user can post a new tweet to their followers (4,6k requests/sec on average, over 12k requests/sec at peak).</li><li><strong>Home timeline</strong> - a user can view tweets posted by the people they follow (300k requests/sec).</li></ul><p>With modern databases, handling 12,000 write requests is achievable fairly easily. But at Twitter, the challenge came not with the volume, but due to so-called <em>fan-out</em>. In transaction processing systems, this term is used to describe the number of requests to other services that need to be made to serve one incoming request. On Twitter, each user follows many people and each user is followed by many people. This means that when a new tweet is published, it needs to be delivered to all of the author&rsquo;s followers. In some cases (e.g. celebrities with many followers), there might be a lot of work to do.</p><p>On a high level, there are two ways of implementing the two operations mentioned above. Let&rsquo;s examine both of them.</p><h3 id=traditional-approach-with-relational-schema>Traditional approach with relational schema<a hidden class=anchor aria-hidden=true href=#traditional-approach-with-relational-schema>#</a></h3><p>This is probably the first approach that comes to most developers&rsquo; minds. The idea is relatively simple. We need some kind of storage for all posted tweets. When a new tweet is posted, it&rsquo;s simply inserted into this global collection of tweets. When a user opens the website and requests their home timeline, all the tweets from all the people they follow are merged and served on demand. In a traditional relational database, you might have three tables to handle this scenario: users, tweets, and follows.</p><ul><li><em>users</em> table</li></ul><table><thead><tr><th>id</th><th>first_name</th><th>last_name</th><th>username</th></tr></thead><tbody><tr><td>21</td><td>Arkadiusz</td><td>Chmura</td><td>ClouddJr</td></tr></tbody></table><ul><li><em>tweets</em> table</li></ul><table><thead><tr><th>id</th><th>user_id</th><th>content</th><th>created_at</th></tr></thead><tbody><tr><td>14</td><td>21</td><td>Hello World!</td><td>2022-03-26 17:46:11</td></tr></tbody></table><ul><li><em>follows</em> table</li></ul><table><thead><tr><th>follower_id</th><th>followee_id</th></tr></thead><tbody><tr><td>19212</td><td>21</td></tr></tbody></table><p>Then, to get all the relevant tweets to assemble a user&rsquo;s timeline, the SQL query could look like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#ff79c6>SELECT</span>
</span></span><span style=display:flex><span>	tweets.<span style=color:#ff79c6>*</span>,
</span></span><span style=display:flex><span>	users.<span style=color:#ff79c6>*</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>FROM</span>
</span></span><span style=display:flex><span>	tweets
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>JOIN</span> users <span style=color:#ff79c6>ON</span> tweets.user_id <span style=color:#ff79c6>=</span> users.id
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>JOIN</span> follows <span style=color:#ff79c6>ON</span> follows.followee_id <span style=color:#ff79c6>=</span> users.id
</span></span><span style=display:flex><span><span style=color:#ff79c6>WHERE</span>
</span></span><span style=display:flex><span>	follows.follower_id <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>CURRENT_USER</span>
</span></span></code></pre></div><p>The biggest problem here is that we have to execute the above query every time we want to display a timeline for any user. It&rsquo;s not hard to imagine the huge amount of work required when there are a lot of users on the platform with a substantial number of people they follow frequently accessing the website.</p><p>The first version of Twitter used this approach, but the system struggled to keep up with the load of home timeline queries. The number of users on the platform kept growing, so they had to introduce another solution.</p><h3 id=maintaining-a-cache-for-individual-timelines>Maintaining a cache for individual timelines<a hidden class=anchor aria-hidden=true href=#maintaining-a-cache-for-individual-timelines>#</a></h3><p>Here, the basic idea is that we prepare, or <em>cache</em>, each user&rsquo;s home timeline ahead of time so that when it&rsquo;s requested, no additional work is required. When a user posts a tweet, besides being stored in a table, it&rsquo;s immediately inserted into timeline caches for all of their followers. Thanks to this, reading a timeline is very cheap, because it has already been computed - it&rsquo;s enough to just read from the cache. There is no need for any other expensive database operations. This concept is visualized in the image below.</p><figure class=align-center><img loading=lazy src=/twitter-caches.png#center alt="Twitter&amp;rsquo;s data pipeline for delivering tweets to followers (2012)"><figcaption><p>Twitter&rsquo;s data pipeline for delivering tweets to followers (2012)</p></figcaption></figure><p>When it comes to actual tools that you could use to implement the timeline caching mechanism, a great option would be a very popular, open-source, in-memory data store called <a href=https://redis.io/><code>Redis</code></a>.</p><p>However, while reading all relevant tweets for each user is very cheap right now, there is one downside of this approach. Posting a tweet now requires a lot of additional work. Besides storing it in a table, it has to be inserted into many other caches. The average number of followers per user is 75, which means 4,6k new tweets per second becomes 345k writes per second to the home timeline caches (4,6k * 75).</p><p>But the average is affected mainly by users with many followers (there are some with more than 30 million). The majority of users have much fewer followers. This means that the extra work required for the <em>fan-out</em> when posting a new tweet is only noticeable for that small number of users with a very large number of followers.</p><p>For this reason, Twitter moved to a hybrid approach to take the best of both worlds. Tweets from &ldquo;regular&rdquo; users continue to be <em>fanned-out</em> to timeline caches, as illustrated above, while tweets from celebrities are excepted from that process. When a home timeline is requested, tweets from celebrities are fetched separately from the database and merged with what&rsquo;s inside the user&rsquo;s cache.</p><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2><p>If you found this story interesting, you might enjoy reading the book it was mentioned in - Designing Data-Intensive Applications. It&rsquo;s a good combination of the theory behind many enterprise-level tools and practical engineering. It compares many tools and approaches, including their strengths and weaknesses, to make it easier for us to decide what&rsquo;s best for our applications.</p></div><footer class=post-footer><nav class=paginav><a class=prev href=https://arkadiuszchmura.com/posts/how-to-change-system-bar-colors-in-compose/><span class=title>« Prev Page</span><br><span>How to change system bar colors using Jetpack Compose</span></a>
<a class=next href=https://arkadiuszchmura.com/posts/how-to-display-responsive-image-from-laravel-medialibrary-in-vue-js/><span class=title>Next Page »</span><br><span>How to display responsive images from Laravel-medialibrary in Vue.js</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://arkadiuszchmura.com/>Arkadiusz Chmura</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>