<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Be careful when converting Flow to LiveData | Arkadiusz Chmura</title><meta name=keywords content><meta name=description content="LiveData created this way will only emit data when it has active observers."><meta name=author content><link rel=canonical href=https://arkadiuszchmura.com/posts/be-careful-when-converting-flow-to-livedata/><link crossorigin=anonymous href=/assets/css/stylesheet.min.9ba27e3c8c2747e1cde460076c0ca4266a90ef93999b5f361979f681b9f778a6.css integrity="sha256-m6J+PIwnR+HN5GAHbAykJmqQ75OZm182GXn2gbn3eKY=" rel="preload stylesheet" as=style><link rel=icon href=https://arkadiuszchmura.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://arkadiuszchmura.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://arkadiuszchmura.com/favicon-32x32.png><link rel=apple-touch-icon href=https://arkadiuszchmura.com/apple-touch-icon.png><link rel=mask-icon href=https://arkadiuszchmura.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.109.0"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Be careful when converting Flow to LiveData"><meta property="og:description" content="LiveData created this way will only emit data when it has active observers."><meta property="og:type" content="article"><meta property="og:url" content="https://arkadiuszchmura.com/posts/be-careful-when-converting-flow-to-livedata/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-12-31T00:00:00+00:00"><meta property="article:modified_time" content="2022-12-31T00:00:00+00:00"><meta property="og:site_name" content="Arkadiusz Chmura"><meta name=twitter:card content="summary"><meta name=twitter:title content="Be careful when converting Flow to LiveData"><meta name=twitter:description content="LiveData created this way will only emit data when it has active observers."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://arkadiuszchmura.com/posts/"},{"@type":"ListItem","position":2,"name":"Be careful when converting Flow to LiveData","item":"https://arkadiuszchmura.com/posts/be-careful-when-converting-flow-to-livedata/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Be careful when converting Flow to LiveData","name":"Be careful when converting Flow to LiveData","description":"LiveData created this way will only emit data when it has active observers.","keywords":[],"articleBody":"Introduction Recently, I’ve been working on a codebase where I had to write a bridging code between a data layer using Flows and a UI layer that still relied on the state exposed as LiveData.\nLuckily, there is a function in the androidx.lifecycle called asLiveData() that allows you to convert a Flow to a LiveData effortlessly. However, there is one caveat to keep in mind when using a LiveData created this way. It will only emit data when it has at least one active observer. If there is an update to the upstream flow and the LiveData is inactive, it will not have the latest value.\nLet me show you a potential problem we might encounter, with an example below:\nExample We have a simple activity that keeps a reference to an AAC ViewModel:\nclass MainActivity : AppCompatActivity() { private val viewModel: MainViewModel by viewModels() override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) } } The MainViewModel looks like this:\nclass MainViewModel : ViewModel() { private val repository = Repository() val state: LiveData = repository.state.asLiveData() } We have a reference to a repository that will act as our trivial data layer. The ViewModel also exposes a state as a LiveData object converted from a StateFlow kept inside the repository using the asLiveData() function mentioned before.\nHere is what the repository looks like:\nclass Repository { private val _state = MutableStateFlow(-1) val state: StateFlow = _state suspend fun update() { _state.emit(Random.nextInt(until = 1000)) } } It’s a simple class with a StateFlow wrapping an integer (that starts with an initial value of -1) that also has a method allowing clients to update the state with a new random number between 0 and 1000.\nLet’s imagine we want to schedule the update as soon as our activity is created. We could do this by creating a method inside the MainViewModel called init() that we would call inside the onCreate() of our activity:\n// MainViewModel fun init() { // update() is suspending, so we launch a new coroutine here viewModelScope.launch { repository.update() } } // MainActivity override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) viewModel.init() } Now, during the creation of our activity, a new coroutine will be launched that will eventually call update() on the repository, generating a random number and emitting it to the state.\nAdditionally, let’s suppose that there is a requirement to send an analytical event containing the newly generated number in our ViewModel. We could write a sendAnalyticalEvent() method in our ViewModel that we will run right after calling the update() method on the repository:\n// MainViewModel fun init() { viewModelScope.launch { repository.update() sendAnalyticalEvent() // \u003c-- NEW } } private fun sendAnalyticalEvent() { // Typically, we would schedule a network request here val liveDataValue = state.value val flowValue = repository.state.value Log.d(\"Current number in LiveData\", \"$liveDataValue\") Log.d(\"Current number in StateFlow\", \"$flowValue\") } Inside this method, we would typically schedule a network request to our backend servers but in this case, let’s see both values from the LiveData and Flow in the Logcat instead:\nNow, that is quite unexpected. You could argue that the LiveData doesn’t have the newest value because there wasn’t enough time to collect it from the upstream flow, and you might be right. But in this case, not only does the LiveData contain an incorrect value, but it’s null! And remember, the initial value of the state in the repository was -1. It can only mean one thing - our LiveData didn’t collect anything from the StateFlow.\nThe reason is that we haven’t started observing the LiveData anywhere. Therefore, it’s considered inactive. And, according to the documentation of the asLiveData() function, in this state, LiveData won’t be collecting any values from the upstream flow:\nCreates a LiveData that has values collected from the origin Flow.\nThe upstream flow collection starts when the returned LiveData becomes active (LiveData.onActive). If the LiveData becomes inactive (LiveData.onInactive) while the flow has not completed, the flow collection will be cancelled after timeoutInMs milliseconds unless the LiveData becomes active again before that timeout (to gracefully handle cases like Activity rotation).\nOnce we start observing the state in our activity (hence making the LiveData active), it will contain the correct (newest) value:\n// MainActivity override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) viewModel.init() viewModel.state.observe(this) { // \u003c-- NEW Log.d(\"Current number in MainActivity\", \"$it\") } } And this is the output from the Logcat:\nIn this example, we use StateFlow, but the same rules apply to SharedFlow. Furthermore, it would be even worse because any events sent to a SharedFlow while the LiveData is inactive would be permanently lost (SharedFlow, by default, doesn’t replay any values to new subscribers).\nSummary Keep in mind that LiveData converted from a Flow using the asLiveData() function will behave slightly differently than expected. It will emit data only when there are active observers. To me, this behavior makes sense because we generally wouldn’t be interested in LiveData values if we didn’t observe it anywhere.\nRegardless, there might be some use cases when you want to access the current value of your LiveData in your ViewModel before you start observing it. After reading this post, I hope you won’t be surprised when encountering seemingly incorrect values in such situations.\n","wordCount":"867","inLanguage":"en","datePublished":"2022-12-31T00:00:00Z","dateModified":"2022-12-31T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://arkadiuszchmura.com/posts/be-careful-when-converting-flow-to-livedata/"},"publisher":{"@type":"Organization","name":"Arkadiusz Chmura","logo":{"@type":"ImageObject","url":"https://arkadiuszchmura.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://arkadiuszchmura.com/ accesskey=h title="Arkadiusz Chmura (Alt + H)">Arkadiusz Chmura</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://arkadiuszchmura.com/archive title=Archive><span>Archive</span></a></li><li><a href=https://arkadiuszchmura.com/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://arkadiuszchmura.com/>Home</a>&nbsp;»&nbsp;<a href=https://arkadiuszchmura.com/posts/>Posts</a></div><h1 class=post-title>Be careful when converting Flow to LiveData</h1><div class=post-meta><span title='2022-12-31 00:00:00 +0000 UTC'>December 31, 2022</span>&nbsp;·&nbsp;5 min</div></header><div class=post-content><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>Recently, I&rsquo;ve been working on a codebase where I had to write a bridging code between a data layer using <code>Flows</code> and a UI layer that still relied on the state exposed as <code>LiveData</code>.</p><p>Luckily, there is a function in the <code>androidx.lifecycle</code> called <code>asLiveData()</code> that allows you to convert a <code>Flow</code> to a <code>LiveData</code> effortlessly. However, there is one caveat to keep in mind when using a <code>LiveData</code> created this way. It will only emit data when it has at least one active observer. If there is an update to the upstream flow and the <code>LiveData</code> is inactive, it will not have the latest value.</p><p>Let me show you a potential problem we might encounter, with an example below:</p><h2 id=example>Example<a hidden class=anchor aria-hidden=true href=#example>#</a></h2><p>We have a simple activity that keeps a reference to an AAC <code>ViewModel</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>MainActivity</span> : AppCompatActivity() {  
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>private</span> <span style=color:#ff79c6>val</span> viewModel: MainViewModel <span style=color:#ff79c6>by</span> viewModels()  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>override</span> <span style=color:#ff79c6>fun</span> <span style=color:#50fa7b>onCreate</span>(savedInstanceState: Bundle?) {  
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>super</span>.onCreate(savedInstanceState)  
</span></span><span style=display:flex><span>        setContentView(<span style=color:#50fa7b>R</span>.layout.activity_main)    
</span></span><span style=display:flex><span>    }  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>MainViewModel</code> looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>MainViewModel</span> : ViewModel() {  
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>private</span> <span style=color:#ff79c6>val</span> repository = Repository()  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>val</span> state: LiveData&lt;Int&gt; = repository.state.asLiveData()  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We have a reference to a repository that will act as our trivial data layer. The <code>ViewModel</code> also exposes a state as a <code>LiveData</code> object converted from a <code>StateFlow</code> kept inside the repository using the <code>asLiveData()</code> function mentioned before.</p><p>Here is what the repository looks like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>Repository</span> {  
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>private</span> <span style=color:#ff79c6>val</span> _state = MutableStateFlow(-<span style=color:#bd93f9>1</span>)  
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>val</span> state: StateFlow&lt;Int&gt; = _state  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>suspend</span> <span style=color:#ff79c6>fun</span> <span style=color:#50fa7b>update</span>() {  
</span></span><span style=display:flex><span>        _state.emit(<span style=color:#50fa7b>Random</span>.nextInt(until = <span style=color:#bd93f9>1000</span>))  
</span></span><span style=display:flex><span>    }  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It&rsquo;s a simple class with a <code>StateFlow</code> wrapping an integer (that starts with an initial value of -1) that also has a method allowing clients to update the state with a new random number between 0 and 1000.</p><p>Let&rsquo;s imagine we want to schedule the update as soon as our activity is created. We could do this by creating a method inside the <code>MainViewModel</code> called <code>init()</code> that we would call inside the <code>onCreate()</code> of our activity:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#6272a4>// MainViewModel
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>fun</span> <span style=color:#50fa7b>init</span>() {
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// update() is suspending, so we launch a new coroutine here
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    viewModelScope.launch {  
</span></span><span style=display:flex><span>        repository.update()
</span></span><span style=display:flex><span>    }  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// MainActivity
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>override</span> <span style=color:#ff79c6>fun</span> <span style=color:#50fa7b>onCreate</span>(savedInstanceState: Bundle?) {  
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>super</span>.onCreate(savedInstanceState)  
</span></span><span style=display:flex><span>    setContentView(<span style=color:#50fa7b>R</span>.layout.activity_main)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    viewModel.<span style=color:#ff79c6>init</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now, during the creation of our activity, a new coroutine will be launched that will eventually call <code>update()</code> on the repository, generating a random number and emitting it to the state.</p><p>Additionally, let&rsquo;s suppose that there is a requirement to send an analytical event containing the newly generated number in our <code>ViewModel</code>. We could write a <code>sendAnalyticalEvent()</code> method in our <code>ViewModel</code> that we will run right after calling the <code>update()</code> method on the repository:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#6272a4>// MainViewModel
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>fun</span> <span style=color:#50fa7b>init</span>() {  
</span></span><span style=display:flex><span>    viewModelScope.launch {  
</span></span><span style=display:flex><span>        repository.update()  
</span></span><span style=display:flex><span>        sendAnalyticalEvent() <span style=color:#6272a4>// &lt;-- NEW
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    }  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#ff79c6>private</span> <span style=color:#ff79c6>fun</span> <span style=color:#50fa7b>sendAnalyticalEvent</span>() {  
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// Typically, we would schedule a network request here  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>val</span> liveDataValue = state.<span style=color:#ff79c6>value</span>  
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>val</span> flowValue = repository.state.<span style=color:#ff79c6>value</span>  
</span></span><span style=display:flex><span>    <span style=color:#50fa7b>Log</span>.d(<span style=color:#f1fa8c>&#34;Current number in LiveData&#34;</span>, <span style=color:#f1fa8c>&#34;</span><span style=color:#f1fa8c>$liveDataValue</span><span style=color:#f1fa8c>&#34;</span>)  
</span></span><span style=display:flex><span>    <span style=color:#50fa7b>Log</span>.d(<span style=color:#f1fa8c>&#34;Current number in StateFlow&#34;</span>, <span style=color:#f1fa8c>&#34;</span><span style=color:#f1fa8c>$flowValue</span><span style=color:#f1fa8c>&#34;</span>)  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Inside this method, we would typically schedule a network request to our backend servers but in this case, let&rsquo;s see both values from the <code>LiveData</code> and <code>Flow</code> in the Logcat instead:</p><figure class=align-center><img loading=lazy src=/flowtolivedata/1.png#center width=350></figure><p>Now, that is quite unexpected. You could argue that the <code>LiveData</code> doesn&rsquo;t have the newest value because there wasn&rsquo;t enough time to collect it from the upstream flow, and you might be right. But in this case, not only does the <code>LiveData</code> contain an incorrect value, but it&rsquo;s null! And remember, the initial value of the state in the repository was -1. It can only mean one thing - our <code>LiveData</code> didn&rsquo;t collect anything from the <code>StateFlow</code>.</p><p>The reason is that we haven&rsquo;t started observing the <code>LiveData</code> anywhere. Therefore, it&rsquo;s considered <strong>inactive</strong>. And, according to the documentation of the <code>asLiveData()</code> function, in this state, <code>LiveData</code> won&rsquo;t be collecting any values from the upstream flow:</p><blockquote><p>Creates a <code>LiveData</code> that has values collected from the origin <code>Flow</code>.</p><p>The upstream flow collection starts when the returned <code>LiveData</code> becomes active (<code>LiveData.onActive</code>). If the <code>LiveData</code> becomes inactive (<code>LiveData.onInactive</code>) while the flow has not completed, the flow collection will be cancelled after <code>timeoutInMs</code> milliseconds unless the <code>LiveData</code> becomes active again before that timeout (to gracefully handle cases like Activity rotation).</p></blockquote><p>Once we start observing the state in our activity (hence making the <code>LiveData</code> active), it will contain the correct (newest) value:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#6272a4>// MainActivity
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>override</span> <span style=color:#ff79c6>fun</span> <span style=color:#50fa7b>onCreate</span>(savedInstanceState: Bundle?) {  
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>super</span>.onCreate(savedInstanceState)  
</span></span><span style=display:flex><span>    setContentView(<span style=color:#50fa7b>R</span>.layout.activity_main)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    viewModel.<span style=color:#ff79c6>init</span>()  
</span></span><span style=display:flex><span>    viewModel.state.observe(<span style=color:#ff79c6>this</span>) { <span style=color:#6272a4>// &lt;-- NEW  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        <span style=color:#50fa7b>Log</span>.d(<span style=color:#f1fa8c>&#34;Current number in MainActivity&#34;</span>, <span style=color:#f1fa8c>&#34;</span><span style=color:#f1fa8c>$it</span><span style=color:#f1fa8c>&#34;</span>)  
</span></span><span style=display:flex><span>    }  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And this is the output from the Logcat:</p><figure class=align-center><img loading=lazy src=/flowtolivedata/2.png#center width=350></figure><p>In this example, we use <code>StateFlow</code>, but the same rules apply to <code>SharedFlow</code>. Furthermore, it would be even worse because any events sent to a <code>SharedFlow</code> while the <code>LiveData</code> is inactive would be permanently lost (<code>SharedFlow</code>, by default, doesn&rsquo;t replay any values to new subscribers).</p><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2><p>Keep in mind that <code>LiveData</code> converted from a <code>Flow</code> using the <code>asLiveData()</code> function will behave slightly differently than expected. It will emit data only when there are active observers. To me, this behavior makes sense because we generally wouldn&rsquo;t be interested in <code>LiveData</code> values if we didn&rsquo;t observe it anywhere.</p><p>Regardless, there might be some use cases when you want to access the current value of your <code>LiveData</code> in your <code>ViewModel</code> before you start observing it. After reading this post, I hope you won&rsquo;t be surprised when encountering seemingly incorrect values in such situations.</p></div><footer class=post-footer><nav class=paginav><a class=next href=https://arkadiuszchmura.com/posts/managing-dotfiles-with-github/><span class=title>Next Page »</span><br><span>Managing dotfiles with GitHub</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://arkadiuszchmura.com/>Arkadiusz Chmura</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>