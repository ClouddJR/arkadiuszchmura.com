<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>How to test intermediate steps in suspending functions | Arkadiusz Chmura</title><meta name=keywords content><meta name=description content="Testing the final result of a suspending function is easy, but what about verifying what happens inside it during the execution?"><meta name=author content><link rel=canonical href=https://arkadiuszchmura.com/posts/how-to-test-intermediate-steps-in-suspending-functions/><link crossorigin=anonymous href=/assets/css/stylesheet.min.fae4cfc4834f76ac6cce4ff8a96ca6d74c7182c0266a365ff62637f339447878.css integrity="sha256-+uTPxINPdqxszk/4qWym10xxgsAmajZf9iY38zlEeHg=" rel="preload stylesheet" as=style><link rel=icon href=https://arkadiuszchmura.com/favicon.ico><link rel=apple-touch-icon href=https://arkadiuszchmura.com/apple-touch-icon.png><meta name=twitter:title content="How to test intermediate steps in suspending functions | Arkadiusz Chmura"><meta name=twitter:description content="Testing the final result of a suspending function is easy, but what about verifying what happens inside it during the execution?"><meta property="og:title" content="How to test intermediate steps in suspending functions | Arkadiusz Chmura"><meta property="og:description" content="Testing the final result of a suspending function is easy, but what about verifying what happens inside it during the execution?"><meta property="og:type" content="article"><meta property="og:url" content="https://arkadiuszchmura.com/posts/how-to-test-intermediate-steps-in-suspending-functions/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-09-30T00:00:00+00:00"><meta property="article:modified_time" content="2022-09-30T00:00:00+00:00"><meta property="og:site_name" content="Arkadiusz Chmura"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://arkadiuszchmura.com/posts/"},{"@type":"ListItem","position":2,"name":"How to test intermediate steps in suspending functions","item":"https://arkadiuszchmura.com/posts/how-to-test-intermediate-steps-in-suspending-functions/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"How to test intermediate steps in suspending functions | Arkadiusz Chmura","name":"How to test intermediate steps in suspending functions","description":"Testing the final result of a suspending function is easy, but what about verifying what happens inside it during the execution?","keywords":[],"wordCount":"1187","inLanguage":"en","datePublished":"2022-09-30T00:00:00Z","dateModified":"2022-09-30T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://arkadiuszchmura.com/posts/how-to-test-intermediate-steps-in-suspending-functions/"},"publisher":{"@type":"Organization","name":"Arkadiusz Chmura","logo":{"@type":"ImageObject","url":"https://arkadiuszchmura.com/favicon.ico"}}}</script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&display=swap" rel=stylesheet><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript></head><body class="type-posts kind-page layout-" id=top><script data-no-instant>function switchTheme(e){switch(e){case"light":document.body.classList.remove("dark");break;case"dark":document.body.classList.add("dark");break;default:window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")}}function isDarkTheme(){return document.body.className.includes("dark")}function getPrefTheme(){return localStorage.getItem("pref-theme")}function setPrefTheme(e){switchTheme(e),localStorage.setItem("pref-theme",e)}const toggleThemeCallbacks={};toggleThemeCallbacks.main=e=>{setPrefTheme(e?"light":"dark")},window.addEventListener("toggle-theme",function(){const e=isDarkTheme();for(const t in toggleThemeCallbacks)toggleThemeCallbacks[t](e)});function toggleThemeListener(){window.dispatchEvent(new CustomEvent("toggle-theme"))}</script><script>(function(){const t="light",e=getPrefTheme(),n=e||t;switchTheme(n)})()</script><header class=header><nav class=nav><div class=logo><a href=https://arkadiuszchmura.com/ accesskey=h title="Arkadiusz Chmura (Alt + H)">Arkadiusz Chmura</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://arkadiuszchmura.com/archive/ title=Archive>Archive</a></li><li><a href=https://arkadiuszchmura.com/search/ title="Search (Alt + /)" data-no-instant accesskey=/>Search</a></li></ul></nav></header><main class="main post"><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://arkadiuszchmura.com/>Home</a>&nbsp;»&nbsp;<a href=https://arkadiuszchmura.com/posts/>Posts</a></div><h1 class=post-title>How to test intermediate steps in suspending functions</h1><div class=post-meta><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>September 30, 2022</span></span><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>6 min</span></span></div></header><div class=post-content><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>¶</a></h2><p>Let&rsquo;s look at a simple suspending function that fetches some data from a server. Before executing a network call, it sets the <code>isLoading</code> variable to <code>true</code>. Then, after finishing successfully, it sets it back to <code>false</code> and returns the loaded data:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>class</span> <span class=nc>Repository</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>    <span class=k>var</span> <span class=py>isLoading</span> <span class=p>=</span> <span class=k>false</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=k>suspend</span> <span class=k>fun</span> <span class=nf>fetchData</span><span class=p>():</span> <span class=n>String</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>        <span class=n>isLoading</span> <span class=p>=</span> <span class=k>true</span>  
</span></span><span class=line><span class=cl>        <span class=n>delay</span><span class=p>(</span><span class=m>500</span><span class=p>)</span> <span class=c1>// Simulate a network call  
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>isLoading</span> <span class=p>=</span> <span class=k>false</span>  
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s2>&#34;Loaded data&#34;</span>  
</span></span><span class=line><span class=cl>    <span class=p>}</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>For simplicity, let&rsquo;s ignore all the additional things we would normally take care of in a real project, like error handling, making the actual network call, parsing the result, etc. Instead, let&rsquo;s focus on the aspect of testing this snippet of code.</p><p>Testing the final result of the <code>fetchData</code> function is relatively easy with the help of some tools from the <code>kotlinx.coroutines.test</code> library. This is what such a test could look like:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=nd>@Test</span>  
</span></span><span class=line><span class=cl><span class=k>fun</span> <span class=nf>`repository should return loaded data`</span><span class=p>()</span> <span class=p>=</span> <span class=n>runTest</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>    <span class=c1>// given  
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>val</span> <span class=py>repository</span> <span class=p>=</span> <span class=n>Repository</span><span class=p>()</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=c1>// when  
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>val</span> <span class=py>result</span> <span class=p>=</span> <span class=n>repository</span><span class=p>.</span><span class=n>fetchData</span><span class=p>()</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=c1>// then  
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>assertEquals</span><span class=p>(</span><span class=s2>&#34;Loaded data&#34;</span><span class=p>,</span> <span class=n>result</span><span class=p>)</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><blockquote><p>Notice how this test doesn&rsquo;t look much different than what we would write if we were testing a regular function.</p></blockquote><p><code>runTest</code> is an extremely convenient function. It behaves similarly to <code>runBlocking</code>, with the difference that the code that it runs will skip delays. Thanks to this, we don&rsquo;t have to wait 500 ms (because of the <code>delay(500)</code> in our <code>fetchData</code> function) for the test to finish.</p><p>The code above works just fine, but what if we want to have more control over this test? We would like to make sure that the <code>fetchData</code> function indeed sets correct values to the <code>isLoading</code> variable - before and after making a network call.</p><h2 id=solution>Solution<a hidden class=anchor aria-hidden=true href=#solution>¶</a></h2><p>We can take advantage of the fact that <code>runTest</code> executes our test body in a new coroutine launched on a <code>TestScope</code>.</p><p>This scope uses a special kind of dispatcher - <code>StandardTestDispatcher</code>. Usually, dispatchers are used to control the thread on which our coroutines should run. This dispatcher does a bit more - it supports delay-skipping using a scheduler that operates on virtual time (<code>TestCoroutineScheduler</code>).</p><p>Coroutines started with the <code>StandardTestDispatcher</code> won&rsquo;t run immediately. Instead, the dispatcher always sends them to its scheduler. Then, it&rsquo;s our job to trigger their execution by controlling the virtual time. For this, we can use functions available on the <code>TestCoroutineScheduler</code>: <code>advanceTimeBy</code>, <code>runCurrent</code> or <code>advanceUntilIdle</code>.</p><p>To see this in action, look at the code below:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=nd>@Test</span>  
</span></span><span class=line><span class=cl><span class=k>fun</span> <span class=nf>`child coroutine`</span><span class=p>()</span> <span class=p>=</span> <span class=n>runTest</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>    <span class=c1>// 1  
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>launch</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>        <span class=c1>// 3  
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>  
</span></span><span class=line><span class=cl>    <span class=c1>// 2  
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>advanceUntilIdle</span><span class=p>()</span> <span class=c1>// Run all the scheduled tasks
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 4  
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>When we call <code>launch</code>, the coroutine is not executed immediately. Instead, as mentioned earlier, it&rsquo;s sent to the scheduler. Only when we call <code>advanceUntilIdle</code> (or any other function controlling the virtual time), the child coroutine is executed.</p><blockquote><p>Notice that we can call <code>advanceUntilIdle</code> directly on the <code>TestScope</code>. It&rsquo;s because it&rsquo;s defined as an extension function that internally delegates the call to the scheduler. The same is true for the remaining functions modifying the virtual time.</p></blockquote><p>This behavior allows us to call the function we want to test inside a child coroutine. That coroutine will be sent to the scheduler and its execution is fully controllable by us.</p><p>We can advance the virtual time to the point where the data is about to be loaded and verify that the <code>isLoading</code> is properly set to <code>true</code>. Then we can run all the tasks scheduled at that time (remember the <code>delay(500)</code> that we had in our function?) by using <code>runCurrent</code>. Lastly, we can assert that the <code>isLoading</code> variable is back to <code>false</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=nd>@Test</span>  
</span></span><span class=line><span class=cl><span class=k>fun</span> <span class=nf>`repository should indicate that it&#39;s loading data`</span><span class=p>()</span> <span class=p>=</span> <span class=n>runTest</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>    <span class=c1>// given  
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>val</span> <span class=py>repository</span> <span class=p>=</span> <span class=n>Repository</span><span class=p>()</span>  
</span></span><span class=line><span class=cl>    <span class=n>launch</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>        <span class=n>repository</span><span class=p>.</span><span class=n>fetchData</span><span class=p>()</span>  
</span></span><span class=line><span class=cl>    <span class=p>}</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=c1>// when  
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>advanceTimeBy</span><span class=p>(</span><span class=m>500</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=c1>// then  
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>assertTrue</span><span class=p>(</span><span class=n>repository</span><span class=p>.</span><span class=n>isLoading</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=c1>// when  
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>runCurrent</span><span class=p>()</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=c1>// then  
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>assertFalse</span><span class=p>(</span><span class=n>repository</span><span class=p>.</span><span class=n>isLoading</span><span class=p>)</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=regular-functions-that-launch-coroutines>Regular functions that launch coroutines<a hidden class=anchor aria-hidden=true href=#regular-functions-that-launch-coroutines>¶</a></h2><p>Previously, we looked at testing intermediate steps in suspending functions. But in some cases, we want to test a regular, non-suspending function that launches a new coroutine inside. It&rsquo;s very common in many Android projects where you can see a code similar to this one:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>class</span> <span class=nc>TasksViewModel</span><span class=p>(</span><span class=k>private</span> <span class=k>val</span> <span class=py>repository</span><span class=p>:</span> <span class=n>TasksRepository</span><span class=p>)</span> <span class=p>:</span> <span class=n>ViewModel</span><span class=p>()</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>    <span class=k>private</span> <span class=k>val</span> <span class=py>_isLoading</span> <span class=p>=</span> <span class=n>MutableStateFlow</span><span class=p>(</span><span class=k>false</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>isLoading</span><span class=p>:</span> <span class=n>StateFlow</span><span class=p>&lt;</span><span class=n>Boolean</span><span class=p>&gt;</span> <span class=p>=</span> <span class=n>_isLoading</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=k>fun</span> <span class=nf>getTasks</span><span class=p>()</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>        <span class=n>viewModelScope</span><span class=p>.</span><span class=n>launch</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>            <span class=n>_isLoading</span><span class=p>.</span><span class=n>emit</span><span class=p>(</span><span class=k>true</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>            <span class=n>repository</span><span class=p>.</span><span class=n>getTasks</span><span class=p>()</span>  
</span></span><span class=line><span class=cl>            <span class=n>_isLoading</span><span class=p>.</span><span class=n>emit</span><span class=p>(</span><span class=k>false</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>        <span class=p>}</span>  
</span></span><span class=line><span class=cl>    <span class=p>}</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>We have a <code>ViewModel</code> that exposes a function called <code>getTasks</code>. Internally, it launches a new coroutine using a <code>viewModelScope</code> in which it calls a suspending function <code>getTasks</code> from our repository. Besides, it correctly updates the <code>isLoading</code> state before and after.</p><p>Here&rsquo;s what the <code>TasksRepository</code> looks like (including the implementation that will be used in tests):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>interface</span> <span class=nc>TasksRepository</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>    <span class=k>suspend</span> <span class=k>fun</span> <span class=nf>getTasks</span><span class=p>():</span> <span class=n>List</span><span class=p>&lt;</span><span class=n>Task</span><span class=p>&gt;</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>InMemoryTasksRepository</span> <span class=p>:</span> <span class=n>TasksRepository</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>    <span class=k>override</span> <span class=k>suspend</span> <span class=k>fun</span> <span class=nf>getTasks</span><span class=p>():</span> <span class=n>List</span><span class=p>&lt;</span><span class=n>Task</span><span class=p>&gt;</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>        <span class=n>delay</span><span class=p>(</span><span class=m>500</span><span class=p>)</span> <span class=c1>// Simulate a network call  
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=n>listOf</span><span class=p>(</span>  
</span></span><span class=line><span class=cl>            <span class=n>Task</span><span class=p>(</span><span class=s2>&#34;1&#34;</span><span class=p>,</span> <span class=s2>&#34;Task 1&#34;</span><span class=p>),</span>  
</span></span><span class=line><span class=cl>            <span class=n>Task</span><span class=p>(</span><span class=s2>&#34;2&#34;</span><span class=p>,</span> <span class=s2>&#34;Task 2&#34;</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>        <span class=p>)</span>  
</span></span><span class=line><span class=cl>    <span class=p>}</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=k>data</span> <span class=k>class</span> <span class=nc>Task</span><span class=p>(</span><span class=k>val</span> <span class=py>id</span><span class=p>:</span> <span class=n>String</span><span class=p>,</span> <span class=k>val</span> <span class=py>name</span><span class=p>:</span> <span class=n>String</span><span class=p>)</span>
</span></span></code></pre></div><p>We can&rsquo;t directly use the same approach as previously, because the coroutine inside <code>getTasks</code> is launched on the <code>viewModelScope</code>. This scope knows nothing about the <code>TestScope</code> that is running our test body. This means that <code>viewModelScope.launch {...}</code> would be launched immediately instead of being scheduled by the <code>StandardTestDispatcher</code>.</p><p>To solve this, we need to force the <code>viewModelScope</code> to use the <code>StandardTestDispatcher</code> that we could control from the outside.</p><p>Luckily, according to the source code, <code>viewModelScope</code> is using a <code>Dispatchers.Main.immediate</code>. The main dispatcher can easily be replaced during tests using <code>Dispatchers.setMain</code>. There, we can pass our <code>StandardTestDispatcher</code>.</p><p>Here&rsquo;s how we could set up our test using the <code>@Before</code> and <code>@After</code> annotations:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>private</span> <span class=k>lateinit</span> <span class=k>var</span> <span class=py>testScheduler</span><span class=p>:</span> <span class=n>TestCoroutineScheduler</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@Before</span>  
</span></span><span class=line><span class=cl><span class=k>fun</span> <span class=nf>setUp</span><span class=p>()</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>    <span class=n>testScheduler</span> <span class=p>=</span> <span class=n>TestCoroutineScheduler</span><span class=p>()</span>  
</span></span><span class=line><span class=cl>    <span class=nc>Dispatchers</span><span class=p>.</span><span class=n>setMain</span><span class=p>(</span><span class=n>StandardTestDispatcher</span><span class=p>(</span><span class=n>testScheduler</span><span class=p>))</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>  
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@After</span>  
</span></span><span class=line><span class=cl><span class=k>fun</span> <span class=nf>tearDown</span><span class=p>()</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>    <span class=nc>Dispatchers</span><span class=p>.</span><span class=n>resetMain</span><span class=p>()</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>  
</span></span></code></pre></div><p>Before each test, we create a <code>StandardTestDispatcher</code>, providing our <code>TestCoroutineScheduler</code>, and set it as the main dispatcher (that we reset after each test).</p><p>Thanks to this, the <code>viewModelScope</code> will be using this dispatcher and all coroutines launched on this scope will be sent to our scheduler.</p><p>The code of our test will be almost identical to the previous one. The only difference is that we don&rsquo;t launch a child coroutine anymore and we control the virtual time by calling methods on the <code>testScheduler</code> variable.</p><p>Here is the full code of our test, including the setup:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>class</span> <span class=nc>ViewModelTest</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>    <span class=k>private</span> <span class=k>lateinit</span> <span class=k>var</span> <span class=py>testScheduler</span><span class=p>:</span> <span class=n>TestCoroutineScheduler</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=nd>@Before</span>  
</span></span><span class=line><span class=cl>    <span class=k>fun</span> <span class=nf>setUp</span><span class=p>()</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>        <span class=n>testScheduler</span> <span class=p>=</span> <span class=n>TestCoroutineScheduler</span><span class=p>()</span>  
</span></span><span class=line><span class=cl>        <span class=nc>Dispatchers</span><span class=p>.</span><span class=n>setMain</span><span class=p>(</span><span class=n>StandardTestDispatcher</span><span class=p>(</span><span class=n>testScheduler</span><span class=p>))</span>  
</span></span><span class=line><span class=cl>    <span class=p>}</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=nd>@After</span>  
</span></span><span class=line><span class=cl>    <span class=k>fun</span> <span class=nf>tearDown</span><span class=p>()</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>        <span class=nc>Dispatchers</span><span class=p>.</span><span class=n>resetMain</span><span class=p>()</span>  
</span></span><span class=line><span class=cl>    <span class=p>}</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=nd>@Test</span>  
</span></span><span class=line><span class=cl>    <span class=k>fun</span> <span class=nf>`should indicate loading when getting the data`</span><span class=p>()</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>        <span class=c1>// given  
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>val</span> <span class=py>viewModel</span> <span class=p>=</span> <span class=n>TasksViewModel</span><span class=p>(</span><span class=n>InMemoryTasksRepository</span><span class=p>())</span>  
</span></span><span class=line><span class=cl>        <span class=n>viewModel</span><span class=p>.</span><span class=n>getTasks</span><span class=p>()</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>        <span class=c1>// when  
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>testScheduler</span><span class=p>.</span><span class=n>advanceTimeBy</span><span class=p>(</span><span class=m>500</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>        <span class=c1>// then  
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>assertTrue</span><span class=p>(</span><span class=n>viewModel</span><span class=p>.</span><span class=n>isLoading</span><span class=p>.</span><span class=k>value</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>        <span class=c1>// when  
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>testScheduler</span><span class=p>.</span><span class=n>runCurrent</span><span class=p>()</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>        <span class=c1>// then  
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>assertFalse</span><span class=p>(</span><span class=n>viewModel</span><span class=p>.</span><span class=n>isLoading</span><span class=p>.</span><span class=k>value</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>    <span class=p>}</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Notice that we don&rsquo;t even have to run our test body inside <code>runTest</code> anymore. That&rsquo;s because we are not calling any suspending functions here - <code>getTasks</code> is a regular function.</p><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>¶</a></h2><p>I hope this post showed you how we can easily make our tests more powerful and controllable when we write code that uses coroutines.</p><p>I first learned the trick of launching a child coroutine in a test to control it from the outside in a book I highly recommend - <a href=https://kt.academy/book/coroutines>Kotlin Coroutines: Deep Dive</a> by Marcin Moskala.</p><p>If you have any questions, feel free to reach me on <a href=https://twitter.com/ClouddJR/>Twitter</a>.</p></div><footer class=post-footer><nav class=paginav><a class=prev href=https://arkadiuszchmura.com/posts/how-to-draw-content-behind-system-bars-in-jetpack-compose/><span class=title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left" style="user-select:text"><line x1="19" y1="12" x2="5" y2="12" style="user-select:text"/><polyline points="12 19 5 12 12 5" style="user-select:text"/></svg>&nbsp;Prev Page</span><br><span>How to draw content behind system bars in Jetpack Compose</span></a>
<a class=next href=https://arkadiuszchmura.com/posts/what-is-the-difference-between-size-and-viewport-size-in-vector-drawables/><span class=title>Next Page&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right" style="user-select:text"><line x1="5" y1="12" x2="19" y2="12" style="user-select:text"/><polyline points="12 5 19 12 12 19" style="user-select:text"/></svg></span><br><span>What is the difference between size and viewport size in vector drawables?</span></a></nav></footer><script src=https://utteranc.es/client.js repo=ClouddJR/arkadiuszchmura.com issue-term=pathname label=comments crossorigin=anonymous async></script><script>function updateUtterancesTheme(e){const t=document.querySelector(".utterances-frame");if(t){const n={type:"set-theme",theme:e?"github-light":"github-dark"};t.contentWindow.postMessage(n,"https://utteranc.es")}}function handleMessageEvent(e){if(e.origin!=="https://utteranc.es")return;const t=!document.body.classList.contains("dark");updateUtterancesTheme(t),removeEventListener("message",handleMessageEvent)}addEventListener("message",handleMessageEvent),toggleThemeCallbacks.comments=updateUtterancesTheme</script></article></main><footer class=footer><span></span>
<span>&copy; 2023 <a href=https://arkadiuszchmura.com/>Arkadiusz Chmura</a></span></footer><script>(function(){const t=""=="1";if(t)return;let e=document.getElementById("theme-toggle");e.removeEventListener("click",toggleThemeListener),e.addEventListener("click",toggleThemeListener)})()</script><script>(function(){let e=document.getElementById("menu");e&&(e.scrollLeft=localStorage.getItem("menu-scroll-position"),e.onscroll=function(){localStorage.setItem("menu-scroll-position",e.scrollLeft)});const t=""=="1",n=""=="1";if(window.matchMedia("(prefers-reduced-motion: reduce)").matches||t||n)return;document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})})()</script><script>if(window.scrollListeners)for(const e of scrollListeners)window.removeEventListener("scroll",e);window.scrollListeners=[]</script><script src=/js/medium-zoom.min.js data-no-instant></script>
<script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script>(function(){const a=""=="1";if(!a)return;if(!document.querySelector(".toc")){console.log("no toc found, ignore toc scroll");return}const r=window.scrollListeners,t=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id]"),n="active";let e=t[0];o(e).classList.add(n);const c=()=>{const s=[];for(const e of t)if(l(e)<5)s.push(e);else break;s.length>0?newActiveHeading=s[s.length-1]:newActiveHeading=t[0],e!=newActiveHeading&&(o(e).classList.remove(n),e=newActiveHeading,o(e).classList.add(n))};let s=null;const i=()=>{s!==null&&clearTimeout(s),s=setTimeout(c,50)};window.addEventListener("scroll",i,!1),r.push(i);function o(e){const t=encodeURI(e.getAttribute("id")).toLowerCase();return document.querySelector(`.toc ul li a[href="#${t}"]`)}function l(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect();return t.top}})()</script><script>mediumZoom(".entry-cover img"),mediumZoom(".post-content img:not([no-zoom])")</script></body></html>