<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>How to test intermediate steps in suspending functions | Arkadiusz Chmura</title><meta name=keywords content><meta name=description content="Testing the final result of a suspending function is easy, but what about verifying what happens inside it during the execution?"><meta name=author content><link rel=canonical href=https://arkadiuszchmura.com/posts/how-to-test-intermediate-steps-in-suspending-functions/><link crossorigin=anonymous href=/assets/css/stylesheet.min.9ba27e3c8c2747e1cde460076c0ca4266a90ef93999b5f361979f681b9f778a6.css integrity="sha256-m6J+PIwnR+HN5GAHbAykJmqQ75OZm182GXn2gbn3eKY=" rel="preload stylesheet" as=style><link rel=icon href=https://arkadiuszchmura.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://arkadiuszchmura.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://arkadiuszchmura.com/favicon-32x32.png><link rel=apple-touch-icon href=https://arkadiuszchmura.com/apple-touch-icon.png><link rel=mask-icon href=https://arkadiuszchmura.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.104.2"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="How to test intermediate steps in suspending functions"><meta property="og:description" content="Testing the final result of a suspending function is easy, but what about verifying what happens inside it during the execution?"><meta property="og:type" content="article"><meta property="og:url" content="https://arkadiuszchmura.com/posts/how-to-test-intermediate-steps-in-suspending-functions/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-09-30T00:00:00+00:00"><meta property="article:modified_time" content="2022-09-30T00:00:00+00:00"><meta property="og:site_name" content="Arkadiusz Chmura"><meta name=twitter:card content="summary"><meta name=twitter:title content="How to test intermediate steps in suspending functions"><meta name=twitter:description content="Testing the final result of a suspending function is easy, but what about verifying what happens inside it during the execution?"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://arkadiuszchmura.com/posts/"},{"@type":"ListItem","position":2,"name":"How to test intermediate steps in suspending functions","item":"https://arkadiuszchmura.com/posts/how-to-test-intermediate-steps-in-suspending-functions/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"How to test intermediate steps in suspending functions","name":"How to test intermediate steps in suspending functions","description":"Testing the final result of a suspending function is easy, but what about verifying what happens inside it during the execution?","keywords":[],"articleBody":"Introduction Let’s look at a simple suspending function that fetches some data from a server. Before executing a network call, it sets the isLoading variable to true. Then, after finishing successfully, it sets it back to false and returns the loaded data:\nclass Repository { var isLoading = false suspend fun fetchData(): String { isLoading = true delay(500) // Simulate a network call isLoading = false return \"Loaded data\" } } For simplicity, let’s ignore all the additional things we would normally take care of in a real project, like error handling, making the actual network call, parsing the result, etc. Instead, let’s focus on the aspect of testing this snippet of code.\nTesting the final result of the fetchData function is relatively easy with the help of some tools from the kotlinx.coroutines.test library. This is what such a test could look like:\n@Test fun `repository should return loaded data`() = runTest { // given val repository = Repository() // when val result = repository.fetchData() // then assertEquals(\"Loaded data\", result) } Notice how this test doesn’t look much different than what we would write if we were testing a regular function.\nrunTest is an extremely convenient function. It behaves similarly to runBlocking, with the difference that the code that it runs will skip delays. Thanks to this, we don’t have to wait 500 ms (because of the delay(500) in our fetchData function) for the test to finish.\nThe code above works just fine, but what if we want to have more control over this test? We would like to make sure that the fetchData function indeed sets correct values to the isLoading variable - before and after making a network call.\nSolution We can take advantage of the fact that runTest executes our test body in a new coroutine launched on a TestScope.\nThis scope uses a special kind of dispatcher - StandardTestDispatcher. Usually, dispatchers are used to control the thread on which our coroutines should run. This dispatcher does a bit more - it supports delay-skipping using a scheduler that operates on virtual time (TestCoroutineScheduler).\nCoroutines started with the StandardTestDispatcher won’t run immediately. Instead, the dispatcher always sends them to its scheduler. Then, it’s our job to trigger their execution by controlling the virtual time. For this, we can use functions available on the TestCoroutineScheduler: advanceTimeBy, runCurrent or advanceUntilIdle.\nTo see this in action, look at the code below:\n@Test fun `child coroutine`() = runTest { // 1 launch { // 3 } // 2 advanceUntilIdle() // Run all the scheduled tasks // 4 } When we call launch, the coroutine is not executed immediately. Instead, as mentioned earlier, it’s sent to the scheduler. Only when we call advanceUntilIdle (or any other function controlling the virtual time), the child coroutine is executed.\nNotice that we can call advanceUntilIdle directly on the TestScope. It’s because it’s defined as an extension function that internally delegates the call to the scheduler. The same is true for the remaining functions modifying the virtual time.\nThis behavior allows us to call the function we want to test inside a child coroutine. That coroutine will be sent to the scheduler and its execution is fully controllable by us.\nWe can advance the virtual time to the point where the data is about to be loaded and verify that the isLoading is properly set to true. Then we can run all the tasks scheduled at that time (remember the delay(500) that we had in our function?) by using runCurrent. Lastly, we can assert that the isLoading variable is back to false:\n@Test fun `repository should indicate that it's loading data`() = runTest { // given val repository = Repository() launch { repository.fetchData() } // when advanceTimeBy(500) // then assertTrue(repository.isLoading) // when runCurrent() // then assertFalse(repository.isLoading) } Regular functions that launch coroutines Previously, we looked at testing intermediate steps in suspending functions. But in some cases, we want to test a regular, non-suspending function that launches a new coroutine inside. It’s very common in many Android projects where you can see a code similar to this one:\nclass TasksViewModel(private val repository: TasksRepository) : ViewModel() { private val _isLoading = MutableStateFlow(false) val isLoading: StateFlow = _isLoading fun getTasks() { viewModelScope.launch { _isLoading.emit(true) repository.getTasks() _isLoading.emit(false) } } } We have a ViewModel that exposes a function called getTasks. Internally, it launches a new coroutine using a viewModelScope in which it calls a suspending function getTasks from our repository. Besides, it correctly updates the isLoading state before and after.\nHere’s what the TasksRepository looks like (including the implementation that will be used in tests):\ninterface TasksRepository { suspend fun getTasks(): List } class InMemoryTasksRepository : TasksRepository { override suspend fun getTasks(): List { delay(500) // Simulate a network call return listOf( Task(\"1\", \"Task 1\"), Task(\"2\", \"Task 2\") ) } } data class Task(val id: String, val name: String) We can’t directly use the same approach as previously, because the coroutine inside getTasks is launched on the viewModelScope. This scope knows nothing about the TestScope that is running our test body. This means that viewModelScope.launch {...} would be launched immediately instead of being scheduled by the StandardTestDispatcher.\nTo solve this, we need to force the viewModelScope to use the StandardTestDispatcher that we could control from the outside.\nLuckily, according to the source code, viewModelScope is using a Dispatchers.Main.immediate. The main dispatcher can easily be replaced during tests using Dispatchers.setMain. There, we can pass our StandardTestDispatcher.\nHere’s how we could set up our test using the @Before and @After annotations:\nprivate lateinit var testScheduler: TestCoroutineScheduler @Before fun setUp() { testScheduler = TestCoroutineScheduler() Dispatchers.setMain(StandardTestDispatcher(testScheduler)) } @After fun tearDown() { Dispatchers.resetMain() } Before each test, we create a StandardTestDispatcher, providing our TestCoroutineScheduler, and set it as the main dispatcher (that we reset after each test).\nThanks to this, the viewModelScope will be using this dispatcher and all coroutines launched on this scope will be sent to our scheduler.\nThe code of our test will be almost identical to the previous one. The only difference is that we don’t launch a child coroutine anymore and we control the virtual time by calling methods on the testScheduler variable.\nHere is the full code of our test, including the setup:\nclass ViewModelTest { private lateinit var testScheduler: TestCoroutineScheduler @Before fun setUp() { testScheduler = TestCoroutineScheduler() Dispatchers.setMain(StandardTestDispatcher(testScheduler)) } @After fun tearDown() { Dispatchers.resetMain() } @Test fun `should indicate loading when getting the data`() { // given val viewModel = TasksViewModel(InMemoryTasksRepository()) viewModel.getTasks() // when testScheduler.advanceTimeBy(500) // then assertTrue(viewModel.isLoading.value) // when testScheduler.runCurrent() // then assertFalse(viewModel.isLoading.value) } } Notice that we don’t even have to run our test body inside runTest anymore. That’s because we are not calling any suspending functions here - getTasks is a regular function.\nConclusion I hope this post showed you how we can easily make our tests more powerful and controllable when we write code that uses coroutines.\nI first learned the trick of launching a child coroutine in a test to control it from the outside in a book I highly recommend - Kotlin Coroutines: Deep Dive by Marcin Moskala.\nIf you have any questions, feel free to reach me on Twitter.\n","wordCount":"1187","inLanguage":"en","datePublished":"2022-09-30T00:00:00Z","dateModified":"2022-09-30T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://arkadiuszchmura.com/posts/how-to-test-intermediate-steps-in-suspending-functions/"},"publisher":{"@type":"Organization","name":"Arkadiusz Chmura","logo":{"@type":"ImageObject","url":"https://arkadiuszchmura.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://arkadiuszchmura.com/ accesskey=h title="Arkadiusz Chmura (Alt + H)">Arkadiusz Chmura</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://arkadiuszchmura.com/archive title=Archive><span>Archive</span></a></li><li><a href=https://arkadiuszchmura.com/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://arkadiuszchmura.com/>Home</a>&nbsp;»&nbsp;<a href=https://arkadiuszchmura.com/posts/>Posts</a></div><h1 class=post-title>How to test intermediate steps in suspending functions</h1><div class=post-meta><span title='2022-09-30 00:00:00 +0000 UTC'>September 30, 2022</span>&nbsp;·&nbsp;6 min</div></header><div class=post-content><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>Let&rsquo;s look at a simple suspending function that fetches some data from a server. Before executing a network call, it sets the <code>isLoading</code> variable to <code>true</code>. Then, after finishing successfully, it sets it back to <code>false</code> and returns the loaded data:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>Repository</span> {  
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>var</span> isLoading = <span style=color:#ff79c6>false</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>suspend</span> <span style=color:#ff79c6>fun</span> <span style=color:#50fa7b>fetchData</span>(): String {  
</span></span><span style=display:flex><span>        isLoading = <span style=color:#ff79c6>true</span>  
</span></span><span style=display:flex><span>        delay(<span style=color:#bd93f9>500</span>) <span style=color:#6272a4>// Simulate a network call  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        isLoading = <span style=color:#ff79c6>false</span>  
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> <span style=color:#f1fa8c>&#34;Loaded data&#34;</span>  
</span></span><span style=display:flex><span>    }  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>For simplicity, let&rsquo;s ignore all the additional things we would normally take care of in a real project, like error handling, making the actual network call, parsing the result, etc. Instead, let&rsquo;s focus on the aspect of testing this snippet of code.</p><p>Testing the final result of the <code>fetchData</code> function is relatively easy with the help of some tools from the <code>kotlinx.coroutines.test</code> library. This is what such a test could look like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>@Test  
</span></span><span style=display:flex><span><span style=color:#ff79c6>fun</span> <span style=color:#50fa7b>`repository should return loaded data`</span>() = runTest {  
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// given  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>val</span> repository = Repository()  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// when  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>val</span> result = repository.fetchData()  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// then  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    assertEquals(<span style=color:#f1fa8c>&#34;Loaded data&#34;</span>, result)  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>Notice how this test doesn&rsquo;t look much different than what we would write if we were testing a regular function.</p></blockquote><p><code>runTest</code> is an extremely convenient function. It behaves similarly to <code>runBlocking</code>, with the difference that the code that it runs will skip delays. Thanks to this, we don&rsquo;t have to wait 500 ms (because of the <code>delay(500)</code> in our <code>fetchData</code> function) for the test to finish.</p><p>The code above works just fine, but what if we want to have more control over this test? We would like to make sure that the <code>fetchData</code> function indeed sets correct values to the <code>isLoading</code> variable - before and after making a network call.</p><h2 id=solution>Solution<a hidden class=anchor aria-hidden=true href=#solution>#</a></h2><p>We can take advantage of the fact that <code>runTest</code> executes our test body in a new coroutine launched on a <code>TestScope</code>.</p><p>This scope uses a special kind of dispatcher - <code>StandardTestDispatcher</code>. Usually, dispatchers are used to control the thread on which our coroutines should run. This dispatcher does a bit more - it supports delay-skipping using a scheduler that operates on virtual time (<code>TestCoroutineScheduler</code>).</p><p>Coroutines started with the <code>StandardTestDispatcher</code> won&rsquo;t run immediately. Instead, the dispatcher always sends them to its scheduler. Then, it&rsquo;s our job to trigger their execution by controlling the virtual time. For this, we can use functions available on the <code>TestCoroutineScheduler</code>: <code>advanceTimeBy</code>, <code>runCurrent</code> or <code>advanceUntilIdle</code>.</p><p>To see this in action, look at the code below:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>@Test  
</span></span><span style=display:flex><span><span style=color:#ff79c6>fun</span> <span style=color:#50fa7b>`child coroutine`</span>() = runTest {  
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 1  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    launch {  
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 3  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    }  
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 2  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    advanceUntilIdle() <span style=color:#6272a4>// Run all the scheduled tasks
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// 4  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>}
</span></span></code></pre></div><p>When we call <code>launch</code>, the coroutine is not executed immediately. Instead, as mentioned earlier, it&rsquo;s sent to the scheduler. Only when we call <code>advanceUntilIdle</code> (or any other function controlling the virtual time), the child coroutine is executed.</p><blockquote><p>Notice that we can call <code>advanceUntilIdle</code> directly on the <code>TestScope</code>. It&rsquo;s because it&rsquo;s defined as an extension function that internally delegates the call to the scheduler. The same is true for the remaining functions modifying the virtual time.</p></blockquote><p>This behavior allows us to call the function we want to test inside a child coroutine. That coroutine will be sent to the scheduler and its execution is fully controllable by us.</p><p>We can advance the virtual time to the point where the data is about to be loaded and verify that the <code>isLoading</code> is properly set to <code>true</code>. Then we can run all the tasks scheduled at that time (remember the <code>delay(500)</code> that we had in our function?) by using <code>runCurrent</code>. Lastly, we can assert that the <code>isLoading</code> variable is back to <code>false</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>@Test  
</span></span><span style=display:flex><span><span style=color:#ff79c6>fun</span> <span style=color:#50fa7b>`repository should indicate that it&#39;s loading data`</span>() = runTest {  
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// given  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>val</span> repository = Repository()  
</span></span><span style=display:flex><span>    launch {  
</span></span><span style=display:flex><span>        repository.fetchData()  
</span></span><span style=display:flex><span>    }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// when  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    advanceTimeBy(<span style=color:#bd93f9>500</span>)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// then  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    assertTrue(repository.isLoading)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// when  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    runCurrent()  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// then  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    assertFalse(repository.isLoading)  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=regular-functions-that-launch-coroutines>Regular functions that launch coroutines<a hidden class=anchor aria-hidden=true href=#regular-functions-that-launch-coroutines>#</a></h2><p>Previously, we looked at testing intermediate steps in suspending functions. But in some cases, we want to test a regular, non-suspending function that launches a new coroutine inside. It&rsquo;s very common in many Android projects where you can see a code similar to this one:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>TasksViewModel</span>(<span style=color:#ff79c6>private</span> <span style=color:#ff79c6>val</span> repository: TasksRepository) : ViewModel() {  
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>private</span> <span style=color:#ff79c6>val</span> _isLoading = MutableStateFlow(<span style=color:#ff79c6>false</span>)  
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>val</span> isLoading: StateFlow&lt;Boolean&gt; = _isLoading  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>fun</span> <span style=color:#50fa7b>getTasks</span>() {  
</span></span><span style=display:flex><span>        viewModelScope.launch {  
</span></span><span style=display:flex><span>            _isLoading.emit(<span style=color:#ff79c6>true</span>)  
</span></span><span style=display:flex><span>            repository.getTasks()  
</span></span><span style=display:flex><span>            _isLoading.emit(<span style=color:#ff79c6>false</span>)  
</span></span><span style=display:flex><span>        }  
</span></span><span style=display:flex><span>    }  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We have a <code>ViewModel</code> that exposes a function called <code>getTasks</code>. Internally, it launches a new coroutine using a <code>viewModelScope</code> in which it calls a suspending function <code>getTasks</code> from our repository. Besides, it correctly updates the <code>isLoading</code> state before and after.</p><p>Here&rsquo;s what the <code>TasksRepository</code> looks like (including the implementation that will be used in tests):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>interface</span> <span style=color:#50fa7b>TasksRepository</span> {  
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>suspend</span> <span style=color:#ff79c6>fun</span> <span style=color:#50fa7b>getTasks</span>(): List&lt;Task&gt;  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>InMemoryTasksRepository</span> : TasksRepository {  
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>override</span> <span style=color:#ff79c6>suspend</span> <span style=color:#ff79c6>fun</span> <span style=color:#50fa7b>getTasks</span>(): List&lt;Task&gt; {  
</span></span><span style=display:flex><span>        delay(<span style=color:#bd93f9>500</span>) <span style=color:#6272a4>// Simulate a network call  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        <span style=color:#ff79c6>return</span> listOf(  
</span></span><span style=display:flex><span>            Task(<span style=color:#f1fa8c>&#34;1&#34;</span>, <span style=color:#f1fa8c>&#34;Task 1&#34;</span>),  
</span></span><span style=display:flex><span>            Task(<span style=color:#f1fa8c>&#34;2&#34;</span>, <span style=color:#f1fa8c>&#34;Task 2&#34;</span>)  
</span></span><span style=display:flex><span>        )  
</span></span><span style=display:flex><span>    }  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#ff79c6>data</span> <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>Task</span>(<span style=color:#ff79c6>val</span> id: String, <span style=color:#ff79c6>val</span> name: String)
</span></span></code></pre></div><p>We can&rsquo;t directly use the same approach as previously, because the coroutine inside <code>getTasks</code> is launched on the <code>viewModelScope</code>. This scope knows nothing about the <code>TestScope</code> that is running our test body. This means that <code>viewModelScope.launch {...}</code> would be launched immediately instead of being scheduled by the <code>StandardTestDispatcher</code>.</p><p>To solve this, we need to force the <code>viewModelScope</code> to use the <code>StandardTestDispatcher</code> that we could control from the outside.</p><p>Luckily, according to the source code, <code>viewModelScope</code> is using a <code>Dispatchers.Main.immediate</code>. The main dispatcher can easily be replaced during tests using <code>Dispatchers.setMain</code>. There, we can pass our <code>StandardTestDispatcher</code>.</p><p>Here&rsquo;s how we could set up our test using the <code>@Before</code> and <code>@After</code> annotations:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>private</span> <span style=color:#ff79c6>lateinit</span> <span style=color:#ff79c6>var</span> testScheduler: TestCoroutineScheduler
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@Before  
</span></span><span style=display:flex><span><span style=color:#ff79c6>fun</span> <span style=color:#50fa7b>setUp</span>() {  
</span></span><span style=display:flex><span>	testScheduler = TestCoroutineScheduler()  
</span></span><span style=display:flex><span>	Dispatchers.setMain(StandardTestDispatcher(testScheduler))  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@After  
</span></span><span style=display:flex><span><span style=color:#ff79c6>fun</span> <span style=color:#50fa7b>tearDown</span>() {  
</span></span><span style=display:flex><span>	Dispatchers.resetMain()  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><p>Before each test, we create a <code>StandardTestDispatcher</code>, providing our <code>TestCoroutineScheduler</code>, and set it as the main dispatcher (that we reset after each test).</p><p>Thanks to this, the <code>viewModelScope</code> will be using this dispatcher and all coroutines launched on this scope will be sent to our scheduler.</p><p>The code of our test will be almost identical to the previous one. The only difference is that we don&rsquo;t launch a child coroutine anymore and we control the virtual time by calling methods on the <code>testScheduler</code> variable.</p><p>Here is the full code of our test, including the setup:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>ViewModelTest</span> {  
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>private</span> <span style=color:#ff79c6>lateinit</span> <span style=color:#ff79c6>var</span> testScheduler: TestCoroutineScheduler  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    @Before  
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>fun</span> <span style=color:#50fa7b>setUp</span>() {  
</span></span><span style=display:flex><span>        testScheduler = TestCoroutineScheduler()  
</span></span><span style=display:flex><span>        Dispatchers.setMain(StandardTestDispatcher(testScheduler))  
</span></span><span style=display:flex><span>    }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    @After  
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>fun</span> <span style=color:#50fa7b>tearDown</span>() {  
</span></span><span style=display:flex><span>        Dispatchers.resetMain()  
</span></span><span style=display:flex><span>    }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    @Test  
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>fun</span> <span style=color:#50fa7b>`should indicate loading when getting the data`</span>() {  
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// given  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        <span style=color:#ff79c6>val</span> viewModel = TasksViewModel(InMemoryTasksRepository())  
</span></span><span style=display:flex><span>        viewModel.getTasks()  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// when  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        testScheduler.advanceTimeBy(<span style=color:#bd93f9>500</span>)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// then  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        assertTrue(viewModel.isLoading.<span style=color:#ff79c6>value</span>)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// when  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        testScheduler.runCurrent()  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// then  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        assertFalse(viewModel.isLoading.<span style=color:#ff79c6>value</span>)  
</span></span><span style=display:flex><span>    }  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Notice that we don&rsquo;t even have to run our test body inside <code>runTest</code> anymore. That&rsquo;s because we are not calling any suspending functions here - <code>getTasks</code> is a regular function.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>I hope this post showed you how we can easily make our tests more powerful and controllable when we write code that uses coroutines.</p><p>I first learned the trick of launching a child coroutine in a test to control it from the outside in a book I highly recommend - <a href=https://kt.academy/book/coroutines>Kotlin Coroutines: Deep Dive</a> by Marcin Moskala.</p><p>If you have any questions, feel free to reach me on <a href=https://twitter.com/ClouddJR/>Twitter</a>.</p></div><footer class=post-footer><nav class=paginav><a class=next href=https://arkadiuszchmura.com/posts/what-is-the-difference-between-size-and-viewport-size-in-vector-drawables/><span class=title>Next Page »</span><br><span>What is the difference between size and viewport size in vector drawables?</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://arkadiuszchmura.com/>Arkadiusz Chmura</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>