<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>How to reliably update widgets on Android | Arkadiusz Chmura</title><meta name=keywords content><meta name=description content="The default solution with android:updatePeriodMillis doesn&rsquo;t always work."><meta name=author content><link rel=canonical href=https://arkadiuszchmura.com/posts/how-to-reliably-update-widgets-on-android/><link crossorigin=anonymous href=/assets/css/stylesheet.min.9ba27e3c8c2747e1cde460076c0ca4266a90ef93999b5f361979f681b9f778a6.css integrity="sha256-m6J+PIwnR+HN5GAHbAykJmqQ75OZm182GXn2gbn3eKY=" rel="preload stylesheet" as=style><link rel=icon href=https://arkadiuszchmura.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://arkadiuszchmura.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://arkadiuszchmura.com/favicon-32x32.png><link rel=apple-touch-icon href=https://arkadiuszchmura.com/apple-touch-icon.png><link rel=mask-icon href=https://arkadiuszchmura.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.109.0"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="How to reliably update widgets on Android"><meta property="og:description" content="The default solution with android:updatePeriodMillis doesn&rsquo;t always work."><meta property="og:type" content="article"><meta property="og:url" content="https://arkadiuszchmura.com/posts/how-to-reliably-update-widgets-on-android/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-02-12T00:00:00+00:00"><meta property="article:modified_time" content="2022-02-12T00:00:00+00:00"><meta property="og:site_name" content="Arkadiusz Chmura"><meta name=twitter:card content="summary"><meta name=twitter:title content="How to reliably update widgets on Android"><meta name=twitter:description content="The default solution with android:updatePeriodMillis doesn&rsquo;t always work."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://arkadiuszchmura.com/posts/"},{"@type":"ListItem","position":2,"name":"How to reliably update widgets on Android","item":"https://arkadiuszchmura.com/posts/how-to-reliably-update-widgets-on-android/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"How to reliably update widgets on Android","name":"How to reliably update widgets on Android","description":"The default solution with android:updatePeriodMillis doesn\u0026rsquo;t always work.","keywords":[],"articleBody":"Introduction Users of one of my apps heavily rely on widgets. They place them on their home screens to count days to specific events. It is therefore important to keep those widgets up to date and refresh them at least once per day.\nNot long ago, I have been getting some emails (as well as 1-star reviews) from my users reporting that their widgets are not being updated properly on their phones.\nThe Android documentation says that to update a widget periodically at some interval, you can specify android:updatePeriodMillis attribute on the widget’s metadata - AppWidgetProviderInfo XML.\nUnfortunately, despite setting this attribute in my app, widgets were still not updated reliably on some users’ phones.\nThe problem might be that some vendors introduce their own set of rules that restrict background processing and ignore this attribute altogether under some circumstances to artificially save some battery life.\nSolution Since I could not count on this attribute alone, I needed another solution to support it. Luckily, Android Jetpack has a component that could help me periodically update widgets - WorkManager. As of writing this article, it is the primary recommended API for background processing.\nQuoting the documentation, WorkManager handles three types of persistent work:\nImmediate: Tasks that must begin immediately and complete soon. May be expedited. Long Running: Tasks which might run for longer, potentially longer than 10 minutes. Deferrable: Scheduled tasks that start at a later time and can run periodically. Support for the third type of work perfectly matched my use case so I decided to give it a try.\nHere are the steps I took to import and setup WorkManager in my app:\n1. Import the library into your Android project (using the newest version):\ndependencies { val work_version = \"2.7.1\" // Java only implementation(\"androidx.work:work-runtime:$work_version\") // Kotlin + coroutines implementation(\"androidx.work:work-runtime-ktx:$work_version\") } 2. Define the work\nHere we specify what our work actually does. We do this by creating our own implementation of the Worker class and overriding the doWork() method. This method runs asynchronously on a background thread provided by WorkManager.\nIn this case, we simply grab a list of relevant widget ids and notify the AppWidgetManager to perform an update on them by sending an Intent.\nclass WidgetUpdateWorker( private val appContext: Context, workerParams: WorkerParameters ) : Worker(appContext, workerParams) { override fun doWork(): Result { // This line might be different in your case val widgetIds = DatabaseRepository.getWidgetIds() val intent = Intent( AppWidgetManager.ACTION_APPWIDGET_UPDATE, null, appContext, MyAppWidgetProvider::class.java ) intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, widgetIds) appContext.sendBroadcast(intent) return Result.success() } } One thing to note here - MyAppWidgetProvider is a subclass of the AppWidgetProvider that is needed when creating a widget.\n3. Define WorkRequest and schedule it\nNow that we defined our work, it is necessary to specify how and when that work should be run. We do this by defining a WorkRequest. In our case, we simply want to run the work periodically at some interval.\nval widgetUpdateRequest = PeriodicWorkRequestBuilder( 4, TimeUnit.HOURS ).build() Finally, we can put everything together and schedule our work. The code below could be placed in the Application.onCreate() or in your main activity’s onCreate().\nWorkManager.getInstance(this).enqueueUniquePeriodicWork( \"widgetUpdateWork\", ExistingPeriodicWorkPolicy.KEEP, widgetUpdateRequest ) The first parameter - \"widgetUpdateWork\" is a unique name that identifies the work.\nThe ExistingPeriodicWorkPolicy.KEEP flag tells the WorkManager to keep using the existing work if there is one already scheduled with the same name.\nThe third parameter is a WorkRequest that we’ve just defined.\nAnd that’s it! The work is now scheduled and our widgets are going to be periodically updated.\nAs a side note, there are many benefits to using the WorkManager versus relying on the standard way of updating the widgets. Here are some of them:\nOnce you specify the android:updatePeriodMillis attribute, it is fixed and cannot be changed in any other way than updating the app with a new value. On the other hand, you can let your users decide how often widgets should be updated with WorkManager and change this value at runtime. WorkManager automatically ensures that the scheduled tasks are going to finish even when the OS decides to kill the app to reclaim some memory. Internally, WorkManager uses JobScheduler (on API 23+) or a combination of AlarmManager and BroadcastReceiver on older versions. This makes it less likely to be restricted by some vendors. After introducing WorkManager, the number of emails from my users about their widgets not being updated properly dropped significantly.\nSummary To summarize, here are the key points from this post:\nSome vendors restrict background processing in order to save some battery life. Because of this, the standard way of updating widgets (with the android:updatePeriodMillis attribute) doesn’t always work. To solve this problem, we can introduce WorkManager that will periodically update widgets and make sure that they are up to date. ","wordCount":"788","inLanguage":"en","datePublished":"2022-02-12T00:00:00Z","dateModified":"2022-02-12T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://arkadiuszchmura.com/posts/how-to-reliably-update-widgets-on-android/"},"publisher":{"@type":"Organization","name":"Arkadiusz Chmura","logo":{"@type":"ImageObject","url":"https://arkadiuszchmura.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://arkadiuszchmura.com/ accesskey=h title="Arkadiusz Chmura (Alt + H)">Arkadiusz Chmura</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://arkadiuszchmura.com/archive title=Archive><span>Archive</span></a></li><li><a href=https://arkadiuszchmura.com/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://arkadiuszchmura.com/>Home</a>&nbsp;»&nbsp;<a href=https://arkadiuszchmura.com/posts/>Posts</a></div><h1 class=post-title>How to reliably update widgets on Android</h1><div class=post-meta><span title='2022-02-12 00:00:00 +0000 UTC'>February 12, 2022</span>&nbsp;·&nbsp;4 min</div></header><div class=post-content><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>Users of <a href="https://play.google.com/store/apps/details?id=com.arkadiusz.dayscounter">one of my apps</a> heavily rely on widgets. They place them on their home screens to count days to specific events. It is therefore important to keep those widgets up to date and refresh them at least once per day.</p><p>Not long ago, I have been getting some emails (as well as 1-star reviews) from my users reporting that their widgets are not being updated properly on their phones.</p><p>The Android documentation says that to update a widget periodically at some interval, you can specify <code>android:updatePeriodMillis</code> attribute on the widget&rsquo;s metadata - AppWidgetProviderInfo XML.</p><p>Unfortunately, despite setting this attribute in my app, widgets were still not updated reliably on some users&rsquo; phones.</p><p>The problem might be that some vendors <a href=https://dontkillmyapp.com/problem>introduce their own set of rules</a> that restrict background processing and ignore this attribute altogether under some circumstances to artificially save some battery life.</p><h2 id=solution>Solution<a hidden class=anchor aria-hidden=true href=#solution>#</a></h2><p>Since I could not count on this attribute alone, I needed another solution to support it. Luckily, Android Jetpack has a component that could help me periodically update widgets - WorkManager. As of writing this article, it is the primary recommended API for background processing.</p><p>Quoting the documentation, WorkManager handles three types of persistent work:</p><ul><li><strong>Immediate</strong>: Tasks that must begin immediately and complete soon. May be expedited.</li><li><strong>Long Running</strong>: Tasks which might run for longer, potentially longer than 10 minutes.</li><li><strong>Deferrable</strong>: Scheduled tasks that start at a later time and can run periodically.</li></ul><p>Support for the third type of work perfectly matched my use case so I decided to give it a try.</p><p>Here are the steps I took to import and setup WorkManager in my app:</p><p><strong>1. Import the library into your Android project (<a href=https://developer.android.com/jetpack/androidx/releases/work>using the newest version</a>):</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-gradle data-lang=gradle><span style=display:flex><span>dependencies <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>    val work_version <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;2.7.1&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// Java only
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    implementation<span style=color:#ff79c6>(</span><span style=color:#f1fa8c>&#34;androidx.work:work-runtime:$work_version&#34;</span><span style=color:#ff79c6>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// Kotlin + coroutines
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    implementation<span style=color:#ff79c6>(</span><span style=color:#f1fa8c>&#34;androidx.work:work-runtime-ktx:$work_version&#34;</span><span style=color:#ff79c6>)</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><p><strong>2. Define the work</strong></p><p>Here we specify what our work actually <strong>does</strong>. We do this by creating our own implementation of the <code>Worker</code> class and overriding the <code>doWork()</code> method. This method runs asynchronously on a background thread provided by WorkManager.</p><p>In this case, we simply grab a list of relevant widget ids and notify the AppWidgetManager to perform an update on them by sending an Intent.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>WidgetUpdateWorker</span>(
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>private</span> <span style=color:#ff79c6>val</span> appContext: Context,
</span></span><span style=display:flex><span>    workerParams: WorkerParameters
</span></span><span style=display:flex><span>) : Worker(appContext, workerParams) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>override</span> <span style=color:#ff79c6>fun</span> <span style=color:#50fa7b>doWork</span>(): Result {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// This line might be different in your case
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        <span style=color:#ff79c6>val</span> widgetIds = <span style=color:#50fa7b>DatabaseRepository</span>.getWidgetIds()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>val</span> intent = Intent(
</span></span><span style=display:flex><span>            <span style=color:#50fa7b>AppWidgetManager</span>.ACTION_APPWIDGET_UPDATE, <span style=color:#ff79c6>null</span>, appContext,
</span></span><span style=display:flex><span>            MyAppWidgetProvider<span style=color:#ff79c6>::</span><span style=color:#ff79c6>class</span>.java
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>        intent.putExtra(<span style=color:#50fa7b>AppWidgetManager</span>.EXTRA_APPWIDGET_IDS, widgetIds)
</span></span><span style=display:flex><span>        appContext.sendBroadcast(intent)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> <span style=color:#50fa7b>Result</span>.success()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>One thing to note here - <code>MyAppWidgetProvider</code> is a subclass of the <code>AppWidgetProvider</code> that is needed when creating a widget.</p><p><strong>3. Define WorkRequest and schedule it</strong></p><p>Now that we defined our work, it is necessary to specify <strong>how</strong> and <strong>when</strong> that work should be run. We do this by defining a <code>WorkRequest</code>. In our case, we simply want to run the work periodically at some interval.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>val</span> widgetUpdateRequest = PeriodicWorkRequestBuilder&lt;WidgetUpdateWorker&gt;(
</span></span><span style=display:flex><span>    <span style=color:#bd93f9>4</span>, <span style=color:#50fa7b>TimeUnit</span>.HOURS
</span></span><span style=display:flex><span>).build()
</span></span></code></pre></div><p>Finally, we can put everything together and schedule our work. The code below could be placed in the <code>Application.onCreate()</code> or in your main activity&rsquo;s <code>onCreate()</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#50fa7b>WorkManager</span>.getInstance(<span style=color:#ff79c6>this</span>).enqueueUniquePeriodicWork(
</span></span><span style=display:flex><span>    <span style=color:#f1fa8c>&#34;widgetUpdateWork&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#50fa7b>ExistingPeriodicWorkPolicy</span>.KEEP,
</span></span><span style=display:flex><span>    widgetUpdateRequest
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>The first parameter - <code>"widgetUpdateWork"</code> is a unique name that identifies the work.</p><p>The <code>ExistingPeriodicWorkPolicy.KEEP</code> flag tells the WorkManager to keep using the existing work if there is one already scheduled with the same name.</p><p>The third parameter is a <code>WorkRequest</code> that we&rsquo;ve just defined.</p><p>And that&rsquo;s it! The work is now scheduled and our widgets are going to be periodically updated.</p><p>As a side note, there are many benefits to using the WorkManager versus relying on the standard way of updating the widgets. Here are some of them:</p><ul><li>Once you specify the <code>android:updatePeriodMillis</code> attribute, it is fixed and cannot be changed in any other way than updating the app with a new value. On the other hand, you can let your users decide how often widgets should be updated with WorkManager and change this value at runtime.</li><li>WorkManager automatically ensures that the scheduled tasks are going to finish even when the OS decides to kill the app to reclaim some memory.</li><li>Internally, WorkManager uses JobScheduler (on API 23+) or a combination of AlarmManager and BroadcastReceiver on older versions. This makes it less likely to be restricted by some vendors.</li></ul><p>After introducing WorkManager, the number of emails from my users about their widgets not being updated properly dropped significantly.</p><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2><p>To summarize, here are the key points from this post:</p><ul><li>Some vendors restrict background processing in order to save some battery life. Because of this, the standard way of updating widgets (with the <code>android:updatePeriodMillis</code> attribute) doesn&rsquo;t always work.</li><li>To solve this problem, we can introduce WorkManager that will periodically update widgets and make sure that they are up to date.</li></ul></div><footer class=post-footer><nav class=paginav><a class=prev href=https://arkadiuszchmura.com/posts/do-not-change-the-package-name-or-class-name-of-your-app-widget-provider/><span class=title>« Prev Page</span><br><span>Do not change the package name or class name of your AppWidgetProvider</span></a>
<a class=next href=https://arkadiuszchmura.com/posts/beware-of-the-order-of-operands-in-some-kotlin-collection-operations/><span class=title>Next Page »</span><br><span>Beware of the order of operands in some Kotlin Collection operations</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://arkadiuszchmura.com/>Arkadiusz Chmura</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>