<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>How ViewModels survive configuration changes | Arkadiusz Chmura</title><meta name=keywords content><meta name=description content="Let&rsquo;s explore their implementation details to see how they achieve this."><meta name=author content><link rel=canonical href=https://arkadiuszchmura.com/posts/how-viewmodels-survive-configuration-changes/><link crossorigin=anonymous href=/assets/css/stylesheet.min.9ba27e3c8c2747e1cde460076c0ca4266a90ef93999b5f361979f681b9f778a6.css integrity="sha256-m6J+PIwnR+HN5GAHbAykJmqQ75OZm182GXn2gbn3eKY=" rel="preload stylesheet" as=style><link rel=icon href=https://arkadiuszchmura.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://arkadiuszchmura.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://arkadiuszchmura.com/favicon-32x32.png><link rel=apple-touch-icon href=https://arkadiuszchmura.com/apple-touch-icon.png><link rel=mask-icon href=https://arkadiuszchmura.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.109.0"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="How ViewModels survive configuration changes"><meta property="og:description" content="Let&rsquo;s explore their implementation details to see how they achieve this."><meta property="og:type" content="article"><meta property="og:url" content="https://arkadiuszchmura.com/posts/how-viewmodels-survive-configuration-changes/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-04-26T00:00:00+00:00"><meta property="article:modified_time" content="2022-04-26T00:00:00+00:00"><meta property="og:site_name" content="Arkadiusz Chmura"><meta name=twitter:card content="summary"><meta name=twitter:title content="How ViewModels survive configuration changes"><meta name=twitter:description content="Let&rsquo;s explore their implementation details to see how they achieve this."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://arkadiuszchmura.com/posts/"},{"@type":"ListItem","position":2,"name":"How ViewModels survive configuration changes","item":"https://arkadiuszchmura.com/posts/how-viewmodels-survive-configuration-changes/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"How ViewModels survive configuration changes","name":"How ViewModels survive configuration changes","description":"Let\u0026rsquo;s explore their implementation details to see how they achieve this.","keywords":[],"articleBody":"Introduction At Google I/O 2017, the Android Framework team introduced Architecture Components - a set of tools that significantly changed how many Android developers write and structure their apps. This post will focus on the internals of one of them - the ViewModel.\nThe ViewModel class is designed to store and manage UI-related data in a lifecycle conscious way. The ViewModel class allows data to survive configuration changes such as screen rotations.\nUsually, one of the first things we find out when learning Android development is that activities get re-created after configuration changes. When it happens, we lose all initialized variables and the view gets re-rendered. We get a completely new activity instance.\nSo when I first heard about the ViewModel class and what it can do, some questions immediately popped up in my head:\nHow is it possible that ViewModels survive configuration changes given that the activities that hold them get destroyed and created again? How does the newly created activity instance access a reference to the same ViewModel used by the previous activity instance? Recently I decided to find answers to those questions. I chose to dive into the Android’s source code and explore the ViewModel’s implementation details.\nCreating a ViewModel Let’s start from the beginning. The recommended approach (at the time of writing this post) to create an instance of a ViewModel class inside an activity is to use the following code:\nprivate val viewModel: MyViewModel by viewModels() where by viewModels() is a syntax representing Kotlin delegated properties.\nThe viewModels() function returns a Lazy instance, which serves as a lazy property delegate. This basically means that a MyViewModel instance is going to be obtained on first access to the viewModel variable (not when this variable is declared).\nHere is what the viewModels() function looks like:\npublic inline fun \u003creified VM : ViewModel\u003e ComponentActivity.viewModels( noinline factoryProducer: (() -\u003e Factory)? = null ): Lazy { val factoryPromise = factoryProducer ?: { defaultViewModelProviderFactory } return ViewModelLazy(VM::class, { viewModelStore }, factoryPromise) } It accepts a single parameter - a factoryProducer. If it’s specified, the ViewModelProvider.Factory returned by this lambda will be used to create a ViewModel instance. If not, the default one will be used.\nThe function returns an instance of the ViewModelLazy class which is an implementation of the Lazy interface that I mentioned earlier.\nThe ViewModelLazy’s constructor takes three parameters. The first one represents a class of the ViewModel we want to create an instance of. The third one is a lambda that returns a ViewModelProvider.Factory. It’s the same one as the one passed to the viewModels() function (or a default one).\nThe second parameter is interesting. It’s a lambda that returns a ViewModelStore. Here, a lambda is passed that returns a viewModelStore variable. Where is this variable coming from?\nAs you can see, the viewModels() function is an extension function on the ComponentActivity class. So when we call viewModelStore in Kotlin, we effectively invoke the getViewModelStore() method from the ComponentActivity (written in Java) that returns its member variable called mViewModelStore:\npublic ViewModelStore getViewModelStore() { if (getApplication() == null) { throw new IllegalStateException(\"Your activity is not yet attached to the \" + \"Application instance. You can't request ViewModel before onCreate call.\"); } ensureViewModelStore(); return mViewModelStore; } The reason why the ComponentActivity has this method is that it implements the ViewModelStoreOwner interface. This is its declaration:\n/** * A scope that owns {@link ViewModelStore}. * * A responsibility of an implementation of this interface is to retain owned ViewModelStore * during the configuration changes and call {@link ViewModelStore#clear()}, when this scope is * going to be destroyed. * * @see ViewTreeViewModelStoreOwner */ @SuppressWarnings(\"WeakerAccess\") public interface ViewModelStoreOwner { /** * Returns owned {@link ViewModelStore} * * @return a {@code ViewModelStore} */ @NonNull ViewModelStore getViewModelStore(); } Now you may ask: “What is ViewModelStore?”\nAs the name suggests, the ViewModelStore class is responsible for storing instances of ViewModels. This is what this class looks like:\npublic class ViewModelStore { private final HashMap\u003cString, ViewModel\u003e mMap = new HashMap\u003c\u003e(); final void put(String key, ViewModel viewModel) { ViewModel oldViewModel = mMap.put(key, viewModel); if (oldViewModel != null) { oldViewModel.onCleared(); } } final ViewModel get(String key) { return mMap.get(key); } Set\u003cString\u003e keys() { return new HashSet\u003c\u003e(mMap.keySet()); } public final void clear() { for (ViewModel vm : mMap.values()) { vm.clear(); } mMap.clear(); } } This relatively simple class serves as a wrapper around HashMap. This is the ultimate place where all ViewModels associated with an activity or a fragment are stored.\nNow, since we know what the ViewModelStore is, it’s clear what the ViewModelStoreOwner interface is used for. A class that implements it indicates to the outside world that it owns an instance of the ViewModelStore.\nThis is a list of all classes in the Android framework that implement the getViewModelStore() method from the ViewModelStoreOwner interface. Basically, it’s only activities and fragments.\nClasses that implement getViewModelStore() from the ViewModelStoreOwner\nLet’s look at the documentation from the ViewModelStoreOwner interface, particularly this fragment:\nA responsibility of an implementation of this interface is to retain owned ViewModelStore during the configuration changes and call ViewModelStore#clear(), when this scope is going to be destroyed.\nThis gives us a valuable hint. It means that it’s the activity’s (or fragment’s) responsibility to make sure that its ViewModelStore (along with all ViewModels) is preserved across configuration changes.\nHow do activities handle that? We will come back to this question in the next section.\nFor now, let’s go back again to the viewModels() function and see what the newly constructed ViewModelLazy class looks like:\npublic class ViewModelLazy ( private val viewModelClass: KClass, private val storeProducer: () -\u003e ViewModelStore, private val factoryProducer: () -\u003e ViewModelProvider.Factory ) : Lazy { private var cached: VM? = null override val value: VM get() { val viewModel = cached return if (viewModel == null) { val factory = factoryProducer() val store = storeProducer() ViewModelProvider(store, factory).get(viewModelClass.java).also { cached = it } } else { viewModel } } override fun isInitialized(): Boolean = cached != null } Most of the code in this class just deals with caching the object and making sure that the same instance is returned on subsequent calls.\nThe most relevant fragment is this one:\nViewModelProvider(store, factory).get(viewModelClass.java) It creates an instance of the ViewModelProvider class by passing the required parameters (that were created by executing the lambdas passed to the constructor) and calls get() to obtain our ViewModel.\nHere’s the get() method:\npublic open operator fun \u003cT : ViewModel\u003e get(modelClass: Class): T { val canonicalName = modelClass.canonicalName ?: throw IllegalArgumentException(\"Local and anonymous classes can not be ViewModels\") return get(\"$DEFAULT_KEY:$canonicalName\", modelClass) } This methods call another get() method that additionally accepts a key as a parameter. In this case, the key is a concatenated string consisting of two parts separated by a colon:\nA DEFAULT_KEY value (which is \"androidx.lifecycle.ViewModelProvider.DefaultKey\"). A canonical name of our ViewModel class. This key will be used to identify our ViewModel object in the HashMap that we saw earlier in the ViewModelStore class.\nHere’s the second get() method:\npublic open operator fun \u003cT : ViewModel\u003e get(key: String, modelClass: Class): T { var viewModel = store[key] if (modelClass.isInstance(viewModel)) { (factory as? OnRequeryFactory)?.onRequery(viewModel) return viewModel as T } else { @Suppress(\"ControlFlowWithEmptyBody\") if (viewModel != null) { // TODO: log a warning. } } viewModel = if (factory is KeyedFactory) { factory.create(key, modelClass) } else { factory.create(modelClass) } store.put(key, viewModel) return viewModel } Without going into too many details, this method basically returns an existing ViewModel specified by the key (if there is one) or creates a new one of the desired type using the provided factory.\nHere we can see the ViewModelStore in action. It’s used to get an existing ViewModel instance (var viewModel = store[key]) or to store a newly created one (store.put(key, viewModel)).\nAt this point, we’ve finally obtained the ViewModel instance that we wanted. It was either the one we already had access to or a completely new instance.\nOk, we’ve covered a lot of ground. It might be worth pausing for a moment to wrap up what we’ve found so far:\nEvery activity and fragment (from the androidx packages) has a component called ViewModelStore. How do we know it? They declare this fact by implementing the ViewModelStoreOwner interface. The ViewModelStore has references to all ViewModels used by this activity or fragment. This component is preserved across configuration changes. Later in this post, we will see how it’s done. When we call private val viewModel: MyViewModel by viewModels() in our activity (or fragment), we create a lazy property delegate that will initialize our ViewModel when we first access the viewModel variable. Internally, the code will create a correct instance and store it in the activity’s (or fragment’s) ViewModelStore or return the previous instance instead (if there was one). The survival We learned that it’s the ViewModelStore that stores our ViewModels. The original question:\nHow ViewModels survive configuration changes?\ncan therefore be rephrased to:\nHow ViewModelStores survive configuration changes?\nLet’s focus on activities. Going back to the getViewModelStore() method from the ComponentActivity, we can notice that it calls another method called ensureViewModelStore() before returning its member instance.\nAs a refresher, here’s the getViewModelStore() method:\npublic ViewModelStore getViewModelStore() { if (getApplication() == null) { throw new IllegalStateException(\"Your activity is not yet attached to the \" + \"Application instance. You can't request ViewModel before onCreate call.\"); } ensureViewModelStore(); return mViewModelStore; } and this is the ensureViewModelStore():\nvoid ensureViewModelStore() { if (mViewModelStore == null) { NonConfigurationInstances nc = (NonConfigurationInstances) getLastNonConfigurationInstance(); if (nc != null) { // Restore the ViewModelStore from NonConfigurationInstances mViewModelStore = nc.viewModelStore; } if (mViewModelStore == null) { mViewModelStore = new ViewModelStore(); } } } And there we go! It seems that we’ve found what we’ve been looking for.\nThis method first checks if the mViewModelStore member variable is null. If it is, we restore the previous ViewModelStore (if there is any, otherwise, it creates a new one) using the getLastNonConfigurationInstance() method. This method returns an instance of the NonConfigurationInstances class that’s defined as follows:\nstatic final class NonConfigurationInstances { Object custom; ViewModelStore viewModelStore; } As we can see, it has our ViewModelStore object.\nNow we know how our ViewModelStores are restored. There is one final piece of the puzzle to solve. We need to find out how they are saved. Let’s start by looking at the documentation of thegetLastNonConfigurationInstance() method:\nRetrieve the non-configuration instance data that was previously returned by onRetainNonConfigurationInstance().\nI think we are getting pretty close. Let’s dive into the onRetainNonConfigurationInstance() method. First, this is what the documentation says about it:\nCalled by the system, as part of destroying an activity due to a configuration change, when it is known that a new instance will immediately be created for the new configuration. You can return any object you like here, including the activity instance itself, which can later be retrieved by calling getLastNonConfigurationInstance() in the new activity instance.\nAnd this is what the method looks like in the ComponentActivity:\npublic final Object onRetainNonConfigurationInstance() { // Skipping the irrelevant parts... NonConfigurationInstances nci = new NonConfigurationInstances(); nci.custom = custom; nci.viewModelStore = viewModelStore; return nci; } As you can see, this method prepares the instance of the NonConfigurationInstances class that will be retained across configuration change. It has our current ViewModelStore which means we will be able to successfuly restore it afterwards in the getLastNonConfigurationInstance().\nAnd that’s it! All that seems so magical about ViewModels at first glance is just a combination of using this pair of methods from the Activity class:\nonRetainNonConfigurationInstance() getLastNonConfigurationInstance() The process of saving and restoring the ViewModelStore in fragments is very similar. If you are interested, I encourage you to explore the source code to find it out by yourself.\nViewModels and process death Here’s one thing worth keeping in mind. As mentioned in the introduction, the ViewModel class allows data to survive configuration changes such as screen rotations, enabling the multi-window mode, etc.\nHowever, the system may destroy your application process while the user is away interacting with other apps. In such a case, the activity instance is destroyed, along with any state stored in it. This is called a process death. ViewModels don’t survive a system-initiated process death.\nThis is why you should use ViewModel objects in combination with onSaveInstanceState() or some other disk persistence. To avoid some boilerplate when using the first approach, you might want to take a look at the SavedStateHandle.\nSummary In order to effectively use ViewModels in our Android apps, it’s not necessary to entirely understand the details of their implementation. However, many developers are simply curious about how some things work behind the scenes. Knowledge of the internals can make it easier to spot potential edge cases or pitfalls and simplify debugging in the future.\nI hope you learned something new after reading this post and that it satisfied your curiosity. If there are still some parts that you find confusing, feel free to reach me on Twitter and ask some questions. I will do my best to answer them.\n","wordCount":"2159","inLanguage":"en","datePublished":"2022-04-26T00:00:00Z","dateModified":"2022-04-26T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://arkadiuszchmura.com/posts/how-viewmodels-survive-configuration-changes/"},"publisher":{"@type":"Organization","name":"Arkadiusz Chmura","logo":{"@type":"ImageObject","url":"https://arkadiuszchmura.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://arkadiuszchmura.com/ accesskey=h title="Arkadiusz Chmura (Alt + H)">Arkadiusz Chmura</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://arkadiuszchmura.com/archive title=Archive><span>Archive</span></a></li><li><a href=https://arkadiuszchmura.com/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://arkadiuszchmura.com/>Home</a>&nbsp;»&nbsp;<a href=https://arkadiuszchmura.com/posts/>Posts</a></div><h1 class=post-title>How ViewModels survive configuration changes</h1><div class=post-meta><span title='2022-04-26 00:00:00 +0000 UTC'>April 26, 2022</span>&nbsp;·&nbsp;11 min</div></header><div class=post-content><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>At Google I/O 2017, the Android Framework team introduced Architecture Components - a set of tools that significantly changed how many Android developers write and structure their apps. This post will focus on the internals of one of them - the <a href=https://developer.android.com/reference/androidx/lifecycle/ViewModel><code>ViewModel</code></a>.</p><p>The <code>ViewModel</code> class is designed to store and manage UI-related data in a lifecycle conscious way. The <code>ViewModel</code> class allows data to <strong>survive configuration changes</strong> such as screen rotations.</p><p>Usually, one of the first things we find out when learning Android development is that activities get re-created after configuration changes. When it happens, we lose all initialized variables and the view gets re-rendered. We get a completely new activity instance.</p><p>So when I first heard about the <code>ViewModel</code> class and what it can do, some questions immediately popped up in my head:</p><ol><li>How is it possible that <code>ViewModels</code> survive configuration changes given that the activities that hold them get destroyed and created again?</li><li>How does the newly created activity instance access a reference to the same <code>ViewModel</code> used by the previous activity instance?</li></ol><p>Recently I decided to find answers to those questions. I chose to dive into the Android&rsquo;s source code and explore the <code>ViewModel</code>&rsquo;s implementation details.</p><h2 id=creating-a-viewmodel>Creating a ViewModel<a hidden class=anchor aria-hidden=true href=#creating-a-viewmodel>#</a></h2><p>Let&rsquo;s start from the beginning. The recommended approach (at the time of writing this post) to create an instance of a <code>ViewModel</code> class inside an activity is to use the following code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>private</span> <span style=color:#ff79c6>val</span> viewModel: MyViewModel <span style=color:#ff79c6>by</span> viewModels()
</span></span></code></pre></div><p>where <code>by viewModels()</code> is a syntax representing <a href=https://kotlinlang.org/docs/delegated-properties.html>Kotlin delegated properties</a>.</p><p>The <code>viewModels()</code> function returns a <code>Lazy&lt;T></code> instance, which serves as a lazy property delegate. This basically means that a <code>MyViewModel</code> instance is going to be obtained on first access to the <code>viewModel</code> variable (not when this variable is declared).</p><p>Here is what the <code>viewModels()</code> function looks like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>public</span> <span style=color:#ff79c6>inline</span> <span style=color:#ff79c6>fun</span> &lt;<span style=color:#ff79c6>reified</span> <span style=color:#50fa7b>VM</span> : <span style=color:#50fa7b>ViewModel</span>&gt; <span style=color:#50fa7b>ComponentActivity</span>.viewModels(  
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>noinline</span> factoryProducer: (() <span style=color:#ff79c6>-&gt;</span> Factory)? = <span style=color:#ff79c6>null</span>  
</span></span><span style=display:flex><span>): Lazy&lt;VM&gt; {  
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>val</span> factoryPromise = factoryProducer <span style=color:#ff79c6>?:</span> {  
</span></span><span style=display:flex><span> 		defaultViewModelProviderFactory  
</span></span><span style=display:flex><span>	}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> ViewModelLazy(VM<span style=color:#ff79c6>::</span><span style=color:#ff79c6>class</span>, { viewModelStore }, factoryPromise)  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It accepts a single parameter - a <code>factoryProducer</code>. If it&rsquo;s specified, the <code>ViewModelProvider.Factory</code> returned by this lambda will be used to create a <code>ViewModel</code> instance. If not, the default one will be used.</p><p>The function returns an instance of the <code>ViewModelLazy</code> class which is an implementation of the <code>Lazy</code> interface that I mentioned earlier.</p><p>The <code>ViewModelLazy</code>&rsquo;s constructor takes three parameters. The first one represents a class of the <code>ViewModel</code> we want to create an instance of. The third one is a lambda that returns a <code>ViewModelProvider.Factory</code>. It&rsquo;s the same one as the one passed to the <code>viewModels()</code> function (or a default one).</p><p>The second parameter is interesting. It&rsquo;s a lambda that returns a <code>ViewModelStore</code>. Here, a lambda is passed that returns a <code>viewModelStore</code> variable. Where is this variable coming from?</p><p>As you can see, the <code>viewModels()</code> function is an extension function on the <code>ComponentActivity</code> class. So when we call <code>viewModelStore</code> in Kotlin, we effectively invoke the <code>getViewModelStore()</code> method from the <code>ComponentActivity</code> (written in Java) that returns its member variable called <code>mViewModelStore</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> ViewModelStore <span style=color:#50fa7b>getViewModelStore</span><span style=color:#ff79c6>()</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span>getApplication<span style=color:#ff79c6>()</span> <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span><span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>throw</span> <span style=color:#ff79c6>new</span> IllegalStateException<span style=color:#ff79c6>(</span><span style=color:#f1fa8c>&#34;Your activity is not yet attached to the &#34;</span>
</span></span><span style=display:flex><span>				<span style=color:#ff79c6>+</span> <span style=color:#f1fa8c>&#34;Application instance. You can&#39;t request ViewModel before onCreate call.&#34;</span><span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>	ensureViewModelStore<span style=color:#ff79c6>();</span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> mViewModelStore<span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><p>The reason why the <code>ComponentActivity</code> has this method is that it implements the <code>ViewModelStoreOwner</code> interface. This is its declaration:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * A scope that owns {@link ViewModelStore}.
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * &lt;p&gt;
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * A responsibility of an implementation of this interface is to retain owned ViewModelStore
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * during the configuration changes and call {@link ViewModelStore#clear()}, when this scope is
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * going to be destroyed.
</span></span></span><span style=display:flex><span><span style=color:#6272a4> *
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * @see ViewTreeViewModelStoreOwner
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span>@SuppressWarnings<span style=color:#ff79c6>(</span><span style=color:#f1fa8c>&#34;WeakerAccess&#34;</span><span style=color:#ff79c6>)</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>interface</span> <span style=color:#50fa7b>ViewModelStoreOwner</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>/**
</span></span></span><span style=display:flex><span><span style=color:#6272a4>     * Returns owned {@link ViewModelStore}
</span></span></span><span style=display:flex><span><span style=color:#6272a4>     *
</span></span></span><span style=display:flex><span><span style=color:#6272a4>     * @return a {@code ViewModelStore}
</span></span></span><span style=display:flex><span><span style=color:#6272a4>     */</span>
</span></span><span style=display:flex><span>    @NonNull
</span></span><span style=display:flex><span>    ViewModelStore <span style=color:#50fa7b>getViewModelStore</span><span style=color:#ff79c6>();</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><p>Now you may ask: &ldquo;What is <code>ViewModelStore</code>?&rdquo;</p><p>As the name suggests, the <code>ViewModelStore</code> class is responsible for <strong>storing</strong> instances of <code>ViewModels</code>. This is what this class looks like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>class</span> <span style=color:#50fa7b>ViewModelStore</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd;font-style:italic>final</span> HashMap<span style=color:#ff79c6>&lt;</span>String<span style=color:#ff79c6>,</span> ViewModel<span style=color:#ff79c6>&gt;</span> mMap <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> HashMap<span style=color:#ff79c6>&lt;&gt;();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>final</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>put</span><span style=color:#ff79c6>(</span>String key<span style=color:#ff79c6>,</span> ViewModel viewModel<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>        ViewModel oldViewModel <span style=color:#ff79c6>=</span> mMap<span style=color:#ff79c6>.</span><span style=color:#50fa7b>put</span><span style=color:#ff79c6>(</span>key<span style=color:#ff79c6>,</span> viewModel<span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span>oldViewModel <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span><span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>            oldViewModel<span style=color:#ff79c6>.</span><span style=color:#50fa7b>onCleared</span><span style=color:#ff79c6>();</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>final</span> ViewModel <span style=color:#50fa7b>get</span><span style=color:#ff79c6>(</span>String key<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> mMap<span style=color:#ff79c6>.</span><span style=color:#50fa7b>get</span><span style=color:#ff79c6>(</span>key<span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Set<span style=color:#ff79c6>&lt;</span>String<span style=color:#ff79c6>&gt;</span> <span style=color:#50fa7b>keys</span><span style=color:#ff79c6>()</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>new</span> HashSet<span style=color:#ff79c6>&lt;&gt;(</span>mMap<span style=color:#ff79c6>.</span><span style=color:#50fa7b>keySet</span><span style=color:#ff79c6>());</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>final</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>clear</span><span style=color:#ff79c6>()</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> <span style=color:#ff79c6>(</span>ViewModel vm <span style=color:#ff79c6>:</span> mMap<span style=color:#ff79c6>.</span><span style=color:#50fa7b>values</span><span style=color:#ff79c6>())</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>            vm<span style=color:#ff79c6>.</span><span style=color:#50fa7b>clear</span><span style=color:#ff79c6>();</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>        mMap<span style=color:#ff79c6>.</span><span style=color:#50fa7b>clear</span><span style=color:#ff79c6>();</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><p>This relatively simple class serves as a wrapper around <code>HashMap&lt;String, ViewModel></code>. This is the ultimate place where all <code>ViewModels</code> associated with an activity or a fragment are stored.</p><p>Now, since we know what the <code>ViewModelStore</code> is, it&rsquo;s clear what the <code>ViewModelStoreOwner</code> interface is used for. A class that implements it indicates to the outside world that it owns an instance of the <code>ViewModelStore</code>.</p><p>This is a list of all classes in the Android framework that implement the <code>getViewModelStore()</code> method from the <code>ViewModelStoreOwner</code> interface. Basically, it&rsquo;s only activities and fragments.</p><figure class=align-center><img loading=lazy src=/getViewModelStore.png#center alt="Classes that implement getViewModelStore() from the ViewModelStoreOwner"><figcaption><p>Classes that implement <code>getViewModelStore()</code> from the <code>ViewModelStoreOwner</code></p></figcaption></figure><p>Let&rsquo;s look at the documentation from the <code>ViewModelStoreOwner</code> interface, particularly this fragment:</p><blockquote><p>A responsibility of an implementation of this interface is to retain owned <code>ViewModelStore</code> during the configuration changes and call <code>ViewModelStore#clear()</code>, when this scope is going to be destroyed.</p></blockquote><p>This gives us a valuable hint. It means that it&rsquo;s the <strong>activity&rsquo;s (or fragment&rsquo;s) responsibility</strong> to make sure that its <code>ViewModelStore</code> (along with all <code>ViewModels</code>) is preserved across configuration changes.</p><p>How do activities handle that? We will come back to this question in the next section.</p><p>For now, let&rsquo;s go back again to the <code>viewModels()</code> function and see what the newly constructed <code>ViewModelLazy</code> class looks like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>public</span> <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>ViewModelLazy</span>&lt;VM : ViewModel&gt; (
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>private</span> <span style=color:#ff79c6>val</span> viewModelClass: KClass&lt;VM&gt;,
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>private</span> <span style=color:#ff79c6>val</span> storeProducer: () <span style=color:#ff79c6>-&gt;</span> ViewModelStore,
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>private</span> <span style=color:#ff79c6>val</span> factoryProducer: () <span style=color:#ff79c6>-&gt;</span> <span style=color:#50fa7b>ViewModelProvider</span>.Factory
</span></span><span style=display:flex><span>) : Lazy&lt;VM&gt; {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>private</span> <span style=color:#ff79c6>var</span> cached: VM? = <span style=color:#ff79c6>null</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>override</span> <span style=color:#ff79c6>val</span> value: VM
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>get</span>() {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>val</span> viewModel = cached
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>if</span> (viewModel <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>val</span> factory = factoryProducer()
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>val</span> store = storeProducer()
</span></span><span style=display:flex><span>                ViewModelProvider(store, factory).<span style=color:#ff79c6>get</span>(viewModelClass.java).also {
</span></span><span style=display:flex><span>                    cached = <span style=color:#ff79c6>it</span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>                viewModel
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>override</span> <span style=color:#ff79c6>fun</span> <span style=color:#50fa7b>isInitialized</span>(): Boolean = cached <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Most of the code in this class just deals with caching the object and making sure that the same instance is returned on subsequent calls.</p><p>The most relevant fragment is this one:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>ViewModelProvider(store, factory).<span style=color:#ff79c6>get</span>(viewModelClass.java)
</span></span></code></pre></div><p>It creates an instance of the <code>ViewModelProvider</code> class by passing the required parameters (that were created by executing the lambdas passed to the constructor) and calls <code>get()</code> to obtain our <code>ViewModel</code>.</p><p>Here&rsquo;s the <code>get()</code> method:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>public</span> <span style=color:#ff79c6>open</span> <span style=color:#ff79c6>operator</span> <span style=color:#ff79c6>fun</span> &lt;<span style=color:#50fa7b>T</span> : <span style=color:#50fa7b>ViewModel</span>&gt; <span style=color:#50fa7b>get</span>(modelClass: Class&lt;T&gt;): T {
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>val</span> canonicalName = modelClass.canonicalName
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>?:</span> <span style=color:#ff79c6>throw</span> IllegalArgumentException(<span style=color:#f1fa8c>&#34;Local and anonymous classes can not be ViewModels&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>get</span>(<span style=color:#f1fa8c>&#34;</span><span style=color:#f1fa8c>$DEFAULT</span><span style=color:#f1fa8c>_KEY:</span><span style=color:#f1fa8c>$canonicalName</span><span style=color:#f1fa8c>&#34;</span>, modelClass)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This methods call another <code>get()</code> method that additionally accepts a key as a parameter. In this case, the key is a concatenated string consisting of two parts separated by a colon:</p><ul><li>A <code>DEFAULT_KEY</code> value (which is <code>"androidx.lifecycle.ViewModelProvider.DefaultKey"</code>).</li><li>A canonical name of our <code>ViewModel</code> class.</li></ul><p>This key will be used to identify our <code>ViewModel</code> object in the <code>HashMap&lt;String, ViewModel></code> that we saw earlier in the <code>ViewModelStore</code> class.</p><p>Here&rsquo;s the second <code>get()</code> method:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>public</span> <span style=color:#ff79c6>open</span> <span style=color:#ff79c6>operator</span> <span style=color:#ff79c6>fun</span> &lt;<span style=color:#50fa7b>T</span> : <span style=color:#50fa7b>ViewModel</span>&gt; <span style=color:#50fa7b>get</span>(key: String, modelClass: Class&lt;T&gt;): T {
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>var</span> viewModel = store[key]
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> (modelClass.isInstance(viewModel)) {
</span></span><span style=display:flex><span>		(factory <span style=color:#ff79c6>as</span>? OnRequeryFactory)<span style=color:#ff79c6>?.</span>onRequery(viewModel)
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> viewModel <span style=color:#ff79c6>as</span> T
</span></span><span style=display:flex><span>	} <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>		@Suppress(<span style=color:#f1fa8c>&#34;ControlFlowWithEmptyBody&#34;</span>)
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> (viewModel <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>			<span style=color:#6272a4>// TODO: log a warning.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	viewModel = <span style=color:#ff79c6>if</span> (factory <span style=color:#ff79c6>is</span> KeyedFactory) {
</span></span><span style=display:flex><span>		factory.create(key, modelClass)
</span></span><span style=display:flex><span>	} <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>		factory.create(modelClass)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	store.put(key, viewModel)
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> viewModel
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Without going into too many details, this method basically returns an existing <code>ViewModel</code> specified by the key (if there is one) or creates a new one of the desired type using the provided factory.</p><p>Here we can see the <code>ViewModelStore</code> in action. It&rsquo;s used to get an existing <code>ViewModel</code> instance (<code>var viewModel = store[key]</code>) or to store a newly created one (<code>store.put(key, viewModel)</code>).</p><p>At this point, we&rsquo;ve finally obtained the <code>ViewModel</code> instance that we wanted. It was either the one we already had access to or a completely new instance.</p><p>Ok, we’ve covered a lot of ground. It might be worth pausing for a moment to wrap up what we’ve found so far:</p><ul><li>Every activity and fragment (from the <code>androidx</code> packages) has a component called <code>ViewModelStore</code>. How do we know it? They declare this fact by implementing the <code>ViewModelStoreOwner</code> interface. The <code>ViewModelStore</code> has references to all <code>ViewModels</code> used by this activity or fragment. This component is preserved across configuration changes. Later in this post, we will see how it&rsquo;s done.</li><li>When we call <code>private val viewModel: MyViewModel by viewModels()</code> in our activity (or fragment), we create a lazy property delegate that will initialize our <code>ViewModel</code> when we first access the <code>viewModel</code> variable. Internally, the code will create a correct instance and store it in the activity&rsquo;s (or fragment&rsquo;s) <code>ViewModelStore</code> or return the previous instance instead (if there was one).</li></ul><h2 id=the-survival>The survival<a hidden class=anchor aria-hidden=true href=#the-survival>#</a></h2><p>We learned that it&rsquo;s the <code>ViewModelStore</code> that stores our <code>ViewModels</code>. The original question:</p><blockquote><p>How ViewModels survive configuration changes?</p></blockquote><p>can therefore be rephrased to:</p><blockquote><p>How <strong>ViewModelStores</strong> survive configuration changes?</p></blockquote><p>Let&rsquo;s focus on activities. Going back to the <code>getViewModelStore()</code> method from the <code>ComponentActivity</code>, we can notice that it calls another method called <code>ensureViewModelStore()</code> before returning its member instance.</p><p>As a refresher, here&rsquo;s the <code>getViewModelStore()</code> method:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> ViewModelStore <span style=color:#50fa7b>getViewModelStore</span><span style=color:#ff79c6>()</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span>getApplication<span style=color:#ff79c6>()</span> <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span><span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>throw</span> <span style=color:#ff79c6>new</span> IllegalStateException<span style=color:#ff79c6>(</span><span style=color:#f1fa8c>&#34;Your activity is not yet attached to the &#34;</span>
</span></span><span style=display:flex><span>				<span style=color:#ff79c6>+</span> <span style=color:#f1fa8c>&#34;Application instance. You can&#39;t request ViewModel before onCreate call.&#34;</span><span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>	ensureViewModelStore<span style=color:#ff79c6>();</span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> mViewModelStore<span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><p>and this is the <code>ensureViewModelStore()</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd>void</span> <span style=color:#50fa7b>ensureViewModelStore</span><span style=color:#ff79c6>()</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span>mViewModelStore <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span><span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>		NonConfigurationInstances nc <span style=color:#ff79c6>=</span>
</span></span><span style=display:flex><span>				<span style=color:#ff79c6>(</span>NonConfigurationInstances<span style=color:#ff79c6>)</span> getLastNonConfigurationInstance<span style=color:#ff79c6>();</span>
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span>nc <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>null</span><span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>			<span style=color:#6272a4>// Restore the ViewModelStore from NonConfigurationInstances
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>			mViewModelStore <span style=color:#ff79c6>=</span> nc<span style=color:#ff79c6>.</span><span style=color:#50fa7b>viewModelStore</span><span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span>mViewModelStore <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span><span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>			mViewModelStore <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ViewModelStore<span style=color:#ff79c6>();</span>
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><p>And there we go! It seems that we&rsquo;ve found what we&rsquo;ve been looking for.</p><p>This method first checks if the <code>mViewModelStore</code> member variable is null. If it is, we <strong>restore</strong> the previous <code>ViewModelStore</code> (if there is any, otherwise, it creates a new one) using the <code>getLastNonConfigurationInstance()</code> method. This method returns an instance of the <code>NonConfigurationInstances</code> class that&rsquo;s defined as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#8be9fd;font-style:italic>final</span> <span style=color:#8be9fd;font-style:italic>class</span> <span style=color:#50fa7b>NonConfigurationInstances</span> <span style=color:#ff79c6>{</span>  
</span></span><span style=display:flex><span>    Object custom<span style=color:#ff79c6>;</span>  
</span></span><span style=display:flex><span>    ViewModelStore viewModelStore<span style=color:#ff79c6>;</span>  
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><p>As we can see, it has our <code>ViewModelStore</code> object.</p><p>Now we know how our <code>ViewModelStores</code> are restored. There is one final piece of the puzzle to solve. We need to find out how they are saved. Let&rsquo;s start by looking at the documentation of the<code>getLastNonConfigurationInstance()</code> method:</p><blockquote><p>Retrieve the non-configuration instance data that was previously returned by <code>onRetainNonConfigurationInstance()</code>.</p></blockquote><p>I think we are getting pretty close. Let&rsquo;s dive into the <code>onRetainNonConfigurationInstance()</code> method. First, this is what the documentation says about it:</p><blockquote><p>Called by the system, as part of destroying an activity due to a configuration change, when it is known that a new instance will immediately be created for the new configuration. You can return any object you like here, including the activity instance itself, which can later be retrieved by calling <code>getLastNonConfigurationInstance()</code> in the new activity instance.</p></blockquote><p>And this is what the method looks like in the <code>ComponentActivity</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>final</span> Object <span style=color:#50fa7b>onRetainNonConfigurationInstance</span><span style=color:#ff79c6>()</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// Skipping the irrelevant parts...
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	
</span></span><span style=display:flex><span>	NonConfigurationInstances nci <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> NonConfigurationInstances<span style=color:#ff79c6>();</span>
</span></span><span style=display:flex><span>	nci<span style=color:#ff79c6>.</span><span style=color:#50fa7b>custom</span> <span style=color:#ff79c6>=</span> custom<span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>	nci<span style=color:#ff79c6>.</span><span style=color:#50fa7b>viewModelStore</span> <span style=color:#ff79c6>=</span> viewModelStore<span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> nci<span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><p>As you can see, this method prepares the instance of the <code>NonConfigurationInstances</code> class that will be retained across configuration change. It has our current <code>ViewModelStore</code> which means we will be able to successfuly restore it afterwards in the <code>getLastNonConfigurationInstance()</code>.</p><p>And that&rsquo;s it! All that seems so magical about <code>ViewModels</code> at first glance is just a combination of using this pair of methods from the <code>Activity</code> class:</p><ul><li><code>onRetainNonConfigurationInstance()</code></li><li><code>getLastNonConfigurationInstance()</code></li></ul><p>The process of saving and restoring the <code>ViewModelStore</code> in fragments is very similar. If you are interested, I encourage you to explore the source code to find it out by yourself.</p><h2 id=viewmodels-and-process-death>ViewModels and process death<a hidden class=anchor aria-hidden=true href=#viewmodels-and-process-death>#</a></h2><p>Here&rsquo;s one thing worth keeping in mind. As mentioned in the introduction, the <code>ViewModel</code> class allows data to survive <strong>configuration changes</strong> such as screen rotations, enabling the multi-window mode, etc.</p><p>However, the system may destroy your application process while the user is away interacting with other apps. In such a case, the activity instance is destroyed, along with any state stored in it. This is called a <em>process death</em>. <code>ViewModels</code> <strong>don&rsquo;t survive</strong> a system-initiated process death.</p><p>This is why you should use <code>ViewModel</code> objects in combination with <code>onSaveInstanceState()</code> or some other disk persistence. To avoid some boilerplate when using the first approach, you might want to take a look at the <a href=https://developer.android.com/topic/libraries/architecture/viewmodel-savedstate>SavedStateHandle</a>.</p><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2><p>In order to effectively use <code>ViewModels</code> in our Android apps, it&rsquo;s not necessary to entirely understand the details of their implementation. However, many developers are simply curious about how some things work behind the scenes. Knowledge of the internals can make it easier to spot potential edge cases or pitfalls and simplify debugging in the future.</p><p>I hope you learned something new after reading this post and that it satisfied your curiosity. If there are still some parts that you find confusing, feel free to reach me on <a href=https://twitter.com/ClouddJR/>Twitter</a> and ask some questions. I will do my best to answer them.</p></div><footer class=post-footer><nav class=paginav><a class=prev href=https://arkadiuszchmura.com/posts/how-to-display-responsive-image-from-laravel-medialibrary-in-vue-js/><span class=title>« Prev Page</span><br><span>How to display responsive images from Laravel-medialibrary in Vue.js</span></a>
<a class=next href=https://arkadiuszchmura.com/posts/my-key-takeaways-from-the-pragmatic-programmer/><span class=title>Next Page »</span><br><span>My key takeaways from The Pragmatic Programmer</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://arkadiuszchmura.com/>Arkadiusz Chmura</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>