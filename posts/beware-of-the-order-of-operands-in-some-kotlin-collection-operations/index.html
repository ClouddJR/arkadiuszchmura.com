<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Beware of the order of operands in some Kotlin Collection operations | Arkadiusz Chmura</title>
<meta name=keywords content><meta name=description content="The order of operands can drastically affect the performance of your code."><meta name=author content><link rel=canonical href=https://arkadiuszchmura.com/posts/beware-of-the-order-of-operands-in-some-kotlin-collection-operations/><link crossorigin=anonymous href=/assets/css/stylesheet.min.2a98b1550cccc65faf3cf4916bdbf4af464fffd9915ac511833ff1fe2426ad22.css integrity="sha256-KpixVQzMxl+vPPSRa9v0r0ZP/9mRWsURgz/x/iQmrSI=" rel="preload stylesheet" as=style><link rel=icon href=https://arkadiuszchmura.com/favicon.ico><link rel=apple-touch-icon href=https://arkadiuszchmura.com/apple-touch-icon.png><script async src="https://www.googletagmanager.com/gtag/js?id=G-9BS720SLJB"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-9BS720SLJB",{anonymize_ip:!1})}</script><meta name=twitter:title content="Beware of the order of operands in some Kotlin Collection operations | Arkadiusz Chmura"><meta name=twitter:description content="The order of operands can drastically affect the performance of your code."><meta property="og:title" content="Beware of the order of operands in some Kotlin Collection operations | Arkadiusz Chmura"><meta property="og:description" content="The order of operands can drastically affect the performance of your code."><meta property="og:type" content="article"><meta property="og:url" content="https://arkadiuszchmura.com/posts/beware-of-the-order-of-operands-in-some-kotlin-collection-operations/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-02-01T00:00:00+00:00"><meta property="article:modified_time" content="2022-02-01T00:00:00+00:00"><meta property="og:site_name" content="Arkadiusz Chmura"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://arkadiuszchmura.com/posts/"},{"@type":"ListItem","position":2,"name":"Beware of the order of operands in some Kotlin Collection operations","item":"https://arkadiuszchmura.com/posts/beware-of-the-order-of-operands-in-some-kotlin-collection-operations/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Beware of the order of operands in some Kotlin Collection operations | Arkadiusz Chmura","name":"Beware of the order of operands in some Kotlin Collection operations","description":"The order of operands can drastically affect the performance of your code.","keywords":[],"wordCount":"1155","inLanguage":"en","datePublished":"2022-02-01T00:00:00Z","dateModified":"2022-02-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://arkadiuszchmura.com/posts/beware-of-the-order-of-operands-in-some-kotlin-collection-operations/"},"publisher":{"@type":"Organization","name":"Arkadiusz Chmura","logo":{"@type":"ImageObject","url":"https://arkadiuszchmura.com/favicon.ico"}}}</script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&display=swap" rel=stylesheet><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript></head><body class="type-posts kind-page layout-" id=top><script data-no-instant>function switchTheme(e){switch(e){case"light":document.body.classList.remove("dark");break;case"dark":document.body.classList.add("dark");break;default:window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")}}function isDarkTheme(){return document.body.className.includes("dark")}function getPrefTheme(){return localStorage.getItem("pref-theme")}function setPrefTheme(e){switchTheme(e),localStorage.setItem("pref-theme",e)}const toggleThemeCallbacks={};toggleThemeCallbacks.main=e=>{setPrefTheme(e?"light":"dark")},window.addEventListener("toggle-theme",function(){const e=isDarkTheme();for(const t in toggleThemeCallbacks)toggleThemeCallbacks[t](e)});function toggleThemeListener(){window.dispatchEvent(new CustomEvent("toggle-theme"))}</script><script>(function(){const t="light",e=getPrefTheme(),n=e||t;switchTheme(n)})()</script><header class=header><nav class=nav><div class=logo><a href=https://arkadiuszchmura.com/ accesskey=h title="Arkadiusz Chmura (Alt + H)">Arkadiusz Chmura</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://arkadiuszchmura.com/archive/ title=Archive>Archive</a></li><li><a href=https://arkadiuszchmura.com/search/ title="Search (Alt + /)" data-no-instant accesskey=/>Search</a></li></ul></nav></header><main class="main post"><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://arkadiuszchmura.com/>Home</a>&nbsp;»&nbsp;<a href=https://arkadiuszchmura.com/posts/>Posts</a></div><h1 class=post-title>Beware of the order of operands in some Kotlin Collection operations</h1><div class=post-meta><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>February 1, 2022</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><span>6 min</span></span></div></header><div class=post-content><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>¶</a></h2><p>In December 2021 I was working on a problem from the <a href=https://adventofcode.com/>Advent of Code 2021</a> that required getting all elements from two collections that were contained in both of them. In Kotlin, there is an extension function for that use case on <code>Iterable</code> called <code>intersect</code>.</p><p>In my case, the first collection was a regular <code>List</code> and the second one was a <code>Set</code>.</p><p>The code that I eventually used was analogical to this one:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>val</span> <span class=py>x</span> <span class=p>=</span> <span class=p>(</span><span class=m>1.</span><span class=p>.</span><span class=m>1</span><span class=n>_000_000</span><span class=p>).</span><span class=n>toList</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=py>y</span> <span class=p>=</span> <span class=p>(</span><span class=m>1.</span><span class=p>.</span><span class=m>100</span><span class=n>_000</span><span class=p>).</span><span class=n>toSet</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>x</span> <span class=n>intersect</span> <span class=n>y</span>
</span></span></code></pre></div><p>However, when refactoring the code, I incidentally changed the order of the operands and the last line became <code>y intersect x</code>.</p><p>Given the fact it was the only modification to the code I made, I was genuinely surprised to find that my program now runs <strong>a couple of times slower</strong>.</p><p>That led me to run some experiments to verify whether this seemingly irrelevant change really affects the performance such drastically or the reason was to be found somewhere else.</p><h2 id=the-experiment>The experiment<a hidden class=anchor aria-hidden=true href=#the-experiment>¶</a></h2><p>I decided to use the same code introduced above and measure the execution time separately for both variants:</p><ul><li>For <code>x intersect y</code>.</li><li>For <code>y intersect x</code>.</li></ul><p>For each variant, the experiment was repeated 20 times on my machine (MacBook Pro 13-inch, early 2015) and the average time was obtained.</p><p>Full code for the experiment:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>val</span> <span class=py>results</span> <span class=p>=</span> <span class=n>mutableListOf</span><span class=p>&lt;</span><span class=n>Long</span><span class=p>&gt;()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>repeat</span><span class=p>(</span><span class=m>20</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>measureTime</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>val</span> <span class=py>x</span> <span class=p>=</span> <span class=p>(</span><span class=m>1.</span><span class=p>.</span><span class=m>1</span><span class=n>_000_000</span><span class=p>).</span><span class=n>toList</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>val</span> <span class=py>y</span> <span class=p>=</span> <span class=p>(</span><span class=m>1.</span><span class=p>.</span><span class=m>100</span><span class=n>_000</span><span class=p>).</span><span class=n>toSet</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>x</span> <span class=n>intersect</span> <span class=n>y</span> <span class=c1>// or y intersect x
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}.</span><span class=n>inWholeMilliseconds</span><span class=p>.</span><span class=n>also</span> <span class=p>{</span> <span class=n>results</span><span class=p>.</span><span class=n>add</span><span class=p>(</span><span class=k>it</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>print</span><span class=p>(</span><span class=n>results</span><span class=p>.</span><span class=n>average</span><span class=p>())</span>
</span></span></code></pre></div><p>Here are the results:</p><table><thead><tr><th>Variant</th><th>Time</th></tr></thead><tbody><tr><td><code>x intersect y</code></td><td>224 ms</td></tr><tr><td><code>y intersect x</code></td><td><strong>4793 ms</strong></td></tr></tbody></table><p>As you can see, the outcome is quite surprising. What&rsquo;s more, the bigger the <code>y</code> collection, the greater the time difference between those two variants.</p><h2 id=findings>Findings<a hidden class=anchor aria-hidden=true href=#findings>¶</a></h2><p>Overall, as I dig deeper into the topic (including the <a href=https://github.com/JetBrains/kotlin/blob/1.6.0/libraries/stdlib/common/src/generated/_Collections.kt#L1670>source code</a> of the <code>intersect</code> function), I realized that the problem is <strong>not</strong> the order of the operands itself, but rather the fact that the second operand in the slower variant was not of type <code>Set</code>.</p><p>Moreover, this problem only exists starting with Kotlin 1.6. In prior versions, both of those tested variants (<code>x intersect y</code> and <code>y intersect x</code>) would yield the same results. That&rsquo;s why it might be worth providing a little story behind this issue:</p><h3 id=before-kotlin-16>Before Kotlin 1.6<a hidden class=anchor aria-hidden=true href=#before-kotlin-16>¶</a></h3><p>In many cases, when running some of the Collection operations (such as aforementioned <code>intersect</code>, <code>minus</code>, <code>removeAll</code> or <code>retainAll</code>), Kotlin tried to optimize them by converting their second operands to a <code>Set</code> under the hood.</p><p>Why would it do that?</p><p>Let&rsquo;s consider the <code>minus</code> operation. It returns a list consisting of elements from the first collection that are not present in the second collection. It does that by filtering the first collection to keep only the items that are not in the second collection. But how does it know that a specific item is not present in that collection? By calling its <code>contains</code> method.</p><p>Typically, the complexity of checking for the existence of an item in a regular list or array is linear. We have to go through each item one by one. On the other hand, that complexity is reduced to a constant time for sets. To check whether an item is present in the set, it is enough to compute its hash code.</p><p>For that specific reason, Kotlin tried to introduce this optimization any time it could to improve the performance. But it was not possible in all cases.</p><p>The problem was that a collection could override its <code>contains</code> method causing some unexpected behavior down the road.</p><p>For instance, imagine we pass a collection with overridden <code>contains</code> method that we count on (for example, an <code>IdentitySet</code>). Kotlin then converts it under the hood to a different type - a <code>HashSet</code>. With this change, we can no longer rely on our custom <code>contains</code> implementation because the initial collection is now of another type. This could lead to some errors that are difficult to debug.</p><p>That is why the optimization was applied only in specific cases:</p><ul><li>When the operand was not implementing a <code>Collection</code> interface (meaning it could not override its <code>contains</code> method).</li><li>When the operand is a known implementation of Collection that doesn&rsquo;t override <code>contains</code> (currently only <code>kotlin.collections.ArrayList</code>)</li></ul><p>However, as it turned out, this optimization was quite problematic for a few reasons:</p><ul><li>The code responsible for deciding whether to convert the second operand to a <code>Set</code> was quite difficult to read. Therefore, it was not obvious at the first glance if it was going to be converted or not.</li><li>Sometimes, we might not be aware of the actual implementation of a specific collection - it could be &ldquo;hidden&rdquo; behind some interface. So, we cannot easily deduce whether it would get converted or not.</li><li>There were some problems (described <a href=https://youtrack.jetbrains.com/issue/KT-24536>here</a>) leading to incorrect results when any element changed its <code>hashCode</code> value after being placed to the converted set.</li></ul><h3 id=since-kotlin-16>Since Kotlin 1.6<a hidden class=anchor aria-hidden=true href=#since-kotlin-16>¶</a></h3><p>For the reasons mentioned above, the Kotlin team decided to remove this optimization entirely. Now, the second operand will <strong>never</strong> be converted to a <code>Set</code>. At most, it will be converted to a <code>List</code> if the operand is not implementing the <code>Collection</code> interface.</p><p>For a full list of affected API, see <a href=https://youtrack.jetbrains.com/issue/KT-45438>this link</a>.</p><p>Because this decision could potentially cause performance degradation in some cases, an inspection was added to inform about this issue offering an option to manually convert the second operand to a <code>Set</code>.</p><figure class=align-center><img loading=lazy src=/inspection.png#center alt="(The argument can be converted to &amp;lsquo;Set&amp;rsquo; to improve performance)" width=550><figcaption>Inspection in IntelliJ IDEA informing about a potential performance issue.<p>(The argument can be converted to &lsquo;Set&rsquo; to improve performance)</p></figcaption></figure><p>For now, it is possible to enable this optimization back on the JVM with a system property (<code>kotlin.collections.convert_arg_to_set_in_removeAll</code>). This will give more time to the developers that were previously relying on this feature to migrate the affected code.</p><p>Although, it is worth mentioning that the possibility of enabling the optimization back is planned to be removed in Kotlin 1.7. The same thing is going to happen to the inspection. It will be <strong>turned off</strong> by default with the next major release. Yet you will be able to turn it on again by going to <code>Preferences</code> -> <code>Editor</code> -> <code>Inspections</code> -> <code>Kotlin</code> -> <code>Other problems</code>.</p><p>They give the following explanation for their decision:</p><blockquote><p>However, we expect this inspection to be quite annoying in places where such time complexity does not that matter, so we plan to disabling it by default in the next version of Kotlin and leaving only an intention.</p></blockquote><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>¶</a></h2><p>To summarize, here are the key points from this post:</p><ul><li>Since Kotlin 1.6, the second operands of some Kotlin Collection operations will no longer be converted to a Set under the hood.</li><li>That may have some performance implications, so an inspection was added to inform you about this issue whenever applicable.</li><li>However, the inspection will be turned off by default with the next major release of Kotlin (1.7). You might want to consider turning it on again if you think your codebase might benefit from having it.</li></ul></div><footer class=post-footer><nav class=paginav><a class=prev href=https://arkadiuszchmura.com/posts/how-to-reliably-update-widgets-on-android/><span class=title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left" style="user-select:text"><line x1="19" y1="12" x2="5" y2="12" style="user-select:text"/><polyline points="12 19 5 12 12 5" style="user-select:text"/></svg>&nbsp;Prev Page</span><br><span>How to reliably update widgets on Android</span></a></nav></footer><div class=newsletter><h2 class=header>Subscribe to my newsletter.</h2><p class=prompt>Enjoyed this post? Subscribe to be notified about my new blog posts that I consider worth sharing.</p><form action=https://tinyletter.com/cloudjr method=post target=popupwindow onsubmit='return window.open("https://tinyletter.com/cloudjr","popupwindow","scrollbars=yes,width=800,height=600"),!0'><label for=email-address class=sr-only>Email address</label>
<input id=email-address name=email type=email autocomplete=email required placeholder="Enter your email">
<button type=submit>Subscribe</button></form></div><script src=https://utteranc.es/client.js repo=ClouddJR/arkadiuszchmura.com issue-term=pathname label=comments crossorigin=anonymous async></script><script>function updateUtterancesTheme(e){const t=document.querySelector(".utterances-frame");if(t){const n={type:"set-theme",theme:e?"github-light":"github-dark"};t.contentWindow.postMessage(n,"https://utteranc.es")}}function handleMessageEvent(e){if(e.origin!=="https://utteranc.es")return;const t=!document.body.classList.contains("dark");updateUtterancesTheme(t),removeEventListener("message",handleMessageEvent)}addEventListener("message",handleMessageEvent),toggleThemeCallbacks.comments=updateUtterancesTheme</script></article></main><footer class=footer><span></span>
<span>&copy; 2023 <a href=https://arkadiuszchmura.com/>Arkadiusz Chmura</a></span></footer><script>(function(){const t=""=="1";if(t)return;let e=document.getElementById("theme-toggle");e.removeEventListener("click",toggleThemeListener),e.addEventListener("click",toggleThemeListener)})()</script><script>(function(){let e=document.getElementById("menu");e&&(e.scrollLeft=localStorage.getItem("menu-scroll-position"),e.onscroll=function(){localStorage.setItem("menu-scroll-position",e.scrollLeft)});const t=""=="1",n=""=="1";if(window.matchMedia("(prefers-reduced-motion: reduce)").matches||t||n)return;document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})})()</script><script>if(window.scrollListeners)for(const e of scrollListeners)window.removeEventListener("scroll",e);window.scrollListeners=[]</script><script src=/js/medium-zoom.min.js data-no-instant></script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script>(function(){const a=""=="1";if(!a)return;if(!document.querySelector(".toc")){console.log("no toc found, ignore toc scroll");return}const r=window.scrollListeners,t=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id]"),n="active";let e=t[0];o(e).classList.add(n);const c=()=>{const s=[];for(const e of t)if(l(e)<5)s.push(e);else break;s.length>0?newActiveHeading=s[s.length-1]:newActiveHeading=t[0],e!=newActiveHeading&&(o(e).classList.remove(n),e=newActiveHeading,o(e).classList.add(n))};let s=null;const i=()=>{s!==null&&clearTimeout(s),s=setTimeout(c,50)};window.addEventListener("scroll",i,!1),r.push(i);function o(e){const t=encodeURI(e.getAttribute("id")).toLowerCase();return document.querySelector(`.toc ul li a[href="#${t}"]`)}function l(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect();return t.top}})()</script><script>mediumZoom(".entry-cover img"),mediumZoom(".post-content img:not([no-zoom])")</script></body></html>