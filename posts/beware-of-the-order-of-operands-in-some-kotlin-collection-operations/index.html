<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Beware of the order of operands in some Kotlin Collection operations | Arkadiusz Chmura</title><meta name=keywords content><meta name=description content="The order of operands can drastically affect the performance of your code."><meta name=author content><link rel=canonical href=https://arkadiuszchmura.com/posts/beware-of-the-order-of-operands-in-some-kotlin-collection-operations/><link crossorigin=anonymous href=/assets/css/stylesheet.min.9ba27e3c8c2747e1cde460076c0ca4266a90ef93999b5f361979f681b9f778a6.css integrity="sha256-m6J+PIwnR+HN5GAHbAykJmqQ75OZm182GXn2gbn3eKY=" rel="preload stylesheet" as=style><link rel=icon href=https://arkadiuszchmura.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://arkadiuszchmura.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://arkadiuszchmura.com/favicon-32x32.png><link rel=apple-touch-icon href=https://arkadiuszchmura.com/apple-touch-icon.png><link rel=mask-icon href=https://arkadiuszchmura.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.109.0"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Beware of the order of operands in some Kotlin Collection operations"><meta property="og:description" content="The order of operands can drastically affect the performance of your code."><meta property="og:type" content="article"><meta property="og:url" content="https://arkadiuszchmura.com/posts/beware-of-the-order-of-operands-in-some-kotlin-collection-operations/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-02-01T00:00:00+00:00"><meta property="article:modified_time" content="2022-02-01T00:00:00+00:00"><meta property="og:site_name" content="Arkadiusz Chmura"><meta name=twitter:card content="summary"><meta name=twitter:title content="Beware of the order of operands in some Kotlin Collection operations"><meta name=twitter:description content="The order of operands can drastically affect the performance of your code."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://arkadiuszchmura.com/posts/"},{"@type":"ListItem","position":2,"name":"Beware of the order of operands in some Kotlin Collection operations","item":"https://arkadiuszchmura.com/posts/beware-of-the-order-of-operands-in-some-kotlin-collection-operations/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Beware of the order of operands in some Kotlin Collection operations","name":"Beware of the order of operands in some Kotlin Collection operations","description":"The order of operands can drastically affect the performance of your code.","keywords":[],"articleBody":"Introduction In December 2021 I was working on a problem from the Advent of Code 2021 that required getting all elements from two collections that were contained in both of them. In Kotlin, there is an extension function for that use case on Iterable called intersect.\nIn my case, the first collection was a regular List and the second one was a Set.\nThe code that I eventually used was analogical to this one:\nval x = (1..1_000_000).toList() val y = (1..100_000).toSet() x intersect y However, when refactoring the code, I incidentally changed the order of the operands and the last line became y intersect x.\nGiven the fact it was the only modification to the code I made, I was genuinely surprised to find that my program now runs a couple of times slower.\nThat led me to run some experiments to verify whether this seemingly irrelevant change really affects the performance such drastically or the reason was to be found somewhere else.\nThe experiment I decided to use the same code introduced above and measure the execution time separately for both variants:\nFor x intersect y. For y intersect x. For each variant, the experiment was repeated 20 times on my machine (MacBook Pro 13-inch, early 2015) and the average time was obtained.\nFull code for the experiment:\nval results = mutableListOf() repeat(20) { measureTime { val x = (1..1_000_000).toList() val y = (1..100_000).toSet() x intersect y // or y intersect x }.inWholeMilliseconds.also { results.add(it) } } print(results.average()) Here are the results:\nVariant Time x intersect y 224 ms y intersect x 4793 ms As you can see, the outcome is quite surprising. What’s more, the bigger the y collection, the greater the time difference between those two variants.\nFindings Overall, as I dig deeper into the topic (including the source code of the intersect function), I realized that the problem is not the order of the operands itself, but rather the fact that the second operand in the slower variant was not of type Set.\nMoreover, this problem only exists starting with Kotlin 1.6. In prior versions, both of those tested variants (x intersect y and y intersect x) would yield the same results. That’s why it might be worth providing a little story behind this issue:\nBefore Kotlin 1.6 In many cases, when running some of the Collection operations (such as aforementioned intersect, minus, removeAll or retainAll), Kotlin tried to optimize them by converting their second operands to a Set under the hood.\nWhy would it do that?\nLet’s consider the minus operation. It returns a list consisting of elements from the first collection that are not present in the second collection. It does that by filtering the first collection to keep only the items that are not in the second collection. But how does it know that a specific item is not present in that collection? By calling its contains method.\nTypically, the complexity of checking for the existence of an item in a regular list or array is linear. We have to go through each item one by one. On the other hand, that complexity is reduced to a constant time for sets. To check whether an item is present in the set, it is enough to compute its hash code.\nFor that specific reason, Kotlin tried to introduce this optimization any time it could to improve the performance. But it was not possible in all cases.\nThe problem was that a collection could override its contains method causing some unexpected behavior down the road.\nFor instance, imagine we pass a collection with overridden contains method that we count on (for example, an IdentitySet). Kotlin then converts it under the hood to a different type - a HashSet. With this change, we can no longer rely on our custom contains implementation because the initial collection is now of another type. This could lead to some errors that are difficult to debug.\nThat is why the optimization was applied only in specific cases:\nWhen the operand was not implementing a Collection interface (meaning it could not override its contains method). When the operand is a known implementation of Collection that doesn’t override contains (currently only kotlin.collections.ArrayList) However, as it turned out, this optimization was quite problematic for a few reasons:\nThe code responsible for deciding whether to convert the second operand to a Set was quite difficult to read. Therefore, it was not obvious at the first glance if it was going to be converted or not. Sometimes, we might not be aware of the actual implementation of a specific collection - it could be “hidden” behind some interface. So, we cannot easily deduce whether it would get converted or not. There were some problems (described here) leading to incorrect results when any element changed its hashCode value after being placed to the converted set. Since Kotlin 1.6 For the reasons mentioned above, the Kotlin team decided to remove this optimization entirely. Now, the second operand will never be converted to a Set. At most, it will be converted to a List if the operand is not implementing the Collection interface.\nFor a full list of affected API, see this link.\nBecause this decision could potentially cause performance degradation in some cases, an inspection was added to inform about this issue offering an option to manually convert the second operand to a Set.\nInspection in IntelliJ IDEA informing about a potential performance issue.(The argument can be converted to ‘Set’ to improve performance)\nFor now, it is possible to enable this optimization back on the JVM with a system property (kotlin.collections.convert_arg_to_set_in_removeAll). This will give more time to the developers that were previously relying on this feature to migrate the affected code.\nAlthough, it is worth mentioning that the possibility of enabling the optimization back is planned to be removed in Kotlin 1.7. The same thing is going to happen to the inspection. It will be turned off by default with the next major release. Yet you will be able to turn it on again by going to Preferences -\u003e Editor -\u003e Inspections -\u003e Kotlin -\u003e Other problems.\nThey give the following explanation for their decision:\nHowever, we expect this inspection to be quite annoying in places where such time complexity does not that matter, so we plan to disabling it by default in the next version of Kotlin and leaving only an intention.\nSummary To summarize, here are the key points from this post:\nSince Kotlin 1.6, the second operands of some Kotlin Collection operations will no longer be converted to a Set under the hood. That may have some performance implications, so an inspection was added to inform you about this issue whenever applicable. However, the inspection will be turned off by default with the next major release of Kotlin (1.7). You might want to consider turning it on again if you think your codebase might benefit from having it. ","wordCount":"1155","inLanguage":"en","datePublished":"2022-02-01T00:00:00Z","dateModified":"2022-02-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://arkadiuszchmura.com/posts/beware-of-the-order-of-operands-in-some-kotlin-collection-operations/"},"publisher":{"@type":"Organization","name":"Arkadiusz Chmura","logo":{"@type":"ImageObject","url":"https://arkadiuszchmura.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://arkadiuszchmura.com/ accesskey=h title="Arkadiusz Chmura (Alt + H)">Arkadiusz Chmura</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://arkadiuszchmura.com/archive title=Archive><span>Archive</span></a></li><li><a href=https://arkadiuszchmura.com/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://arkadiuszchmura.com/>Home</a>&nbsp;»&nbsp;<a href=https://arkadiuszchmura.com/posts/>Posts</a></div><h1 class=post-title>Beware of the order of operands in some Kotlin Collection operations</h1><div class=post-meta><span title='2022-02-01 00:00:00 +0000 UTC'>February 1, 2022</span>&nbsp;·&nbsp;6 min</div></header><div class=post-content><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>In December 2021 I was working on a problem from the <a href=https://adventofcode.com/>Advent of Code 2021</a> that required getting all elements from two collections that were contained in both of them. In Kotlin, there is an extension function for that use case on <code>Iterable</code> called <code>intersect</code>.</p><p>In my case, the first collection was a regular <code>List</code> and the second one was a <code>Set</code>.</p><p>The code that I eventually used was analogical to this one:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>val</span> x = (<span style=color:#bd93f9>1.</span>.<span style=color:#bd93f9>1</span>_000_000).toList()
</span></span><span style=display:flex><span><span style=color:#ff79c6>val</span> y = (<span style=color:#bd93f9>1.</span>.<span style=color:#bd93f9>100</span>_000).toSet()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>x intersect y
</span></span></code></pre></div><p>However, when refactoring the code, I incidentally changed the order of the operands and the last line became <code>y intersect x</code>.</p><p>Given the fact it was the only modification to the code I made, I was genuinely surprised to find that my program now runs <strong>a couple of times slower</strong>.</p><p>That led me to run some experiments to verify whether this seemingly irrelevant change really affects the performance such drastically or the reason was to be found somewhere else.</p><h2 id=the-experiment>The experiment<a hidden class=anchor aria-hidden=true href=#the-experiment>#</a></h2><p>I decided to use the same code introduced above and measure the execution time separately for both variants:</p><ul><li>For <code>x intersect y</code>.</li><li>For <code>y intersect x</code>.</li></ul><p>For each variant, the experiment was repeated 20 times on my machine (MacBook Pro 13-inch, early 2015) and the average time was obtained.</p><p>Full code for the experiment:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>val</span> results = mutableListOf&lt;Long&gt;()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>repeat(<span style=color:#bd93f9>20</span>) {
</span></span><span style=display:flex><span>    measureTime {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>val</span> x = (<span style=color:#bd93f9>1.</span>.<span style=color:#bd93f9>1</span>_000_000).toList()
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>val</span> y = (<span style=color:#bd93f9>1.</span>.<span style=color:#bd93f9>100</span>_000).toSet()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        x intersect y <span style=color:#6272a4>// or y intersect x
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    }.inWholeMilliseconds.also { results.add(<span style=color:#ff79c6>it</span>) }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(results.average())
</span></span></code></pre></div><p>Here are the results:</p><table><thead><tr><th>Variant</th><th>Time</th></tr></thead><tbody><tr><td><code>x intersect y</code></td><td>224 ms</td></tr><tr><td><code>y intersect x</code></td><td><strong>4793 ms</strong></td></tr></tbody></table><p>As you can see, the outcome is quite surprising. What&rsquo;s more, the bigger the <code>y</code> collection, the greater the time difference between those two variants.</p><h2 id=findings>Findings<a hidden class=anchor aria-hidden=true href=#findings>#</a></h2><p>Overall, as I dig deeper into the topic (including the <a href=https://github.com/JetBrains/kotlin/blob/1.6.0/libraries/stdlib/common/src/generated/_Collections.kt#L1670>source code</a> of the <code>intersect</code> function), I realized that the problem is <strong>not</strong> the order of the operands itself, but rather the fact that the second operand in the slower variant was not of type <code>Set</code>.</p><p>Moreover, this problem only exists starting with Kotlin 1.6. In prior versions, both of those tested variants (<code>x intersect y</code> and <code>y intersect x</code>) would yield the same results. That&rsquo;s why it might be worth providing a little story behind this issue:</p><h3 id=before-kotlin-16>Before Kotlin 1.6<a hidden class=anchor aria-hidden=true href=#before-kotlin-16>#</a></h3><p>In many cases, when running some of the Collection operations (such as aforementioned <code>intersect</code>, <code>minus</code>, <code>removeAll</code> or <code>retainAll</code>), Kotlin tried to optimize them by converting their second operands to a <code>Set</code> under the hood.</p><p>Why would it do that?</p><p>Let&rsquo;s consider the <code>minus</code> operation. It returns a list consisting of elements from the first collection that are not present in the second collection. It does that by filtering the first collection to keep only the items that are not in the second collection. But how does it know that a specific item is not present in that collection? By calling its <code>contains</code> method.</p><p>Typically, the complexity of checking for the existence of an item in a regular list or array is linear. We have to go through each item one by one. On the other hand, that complexity is reduced to a constant time for sets. To check whether an item is present in the set, it is enough to compute its hash code.</p><p>For that specific reason, Kotlin tried to introduce this optimization any time it could to improve the performance. But it was not possible in all cases.</p><p>The problem was that a collection could override its <code>contains</code> method causing some unexpected behavior down the road.</p><p>For instance, imagine we pass a collection with overridden <code>contains</code> method that we count on (for example, an <code>IdentitySet</code>). Kotlin then converts it under the hood to a different type - a <code>HashSet</code>. With this change, we can no longer rely on our custom <code>contains</code> implementation because the initial collection is now of another type. This could lead to some errors that are difficult to debug.</p><p>That is why the optimization was applied only in specific cases:</p><ul><li>When the operand was not implementing a <code>Collection</code> interface (meaning it could not override its <code>contains</code> method).</li><li>When the operand is a known implementation of Collection that doesn&rsquo;t override <code>contains</code> (currently only <code>kotlin.collections.ArrayList</code>)</li></ul><p>However, as it turned out, this optimization was quite problematic for a few reasons:</p><ul><li>The code responsible for deciding whether to convert the second operand to a <code>Set</code> was quite difficult to read. Therefore, it was not obvious at the first glance if it was going to be converted or not.</li><li>Sometimes, we might not be aware of the actual implementation of a specific collection - it could be &ldquo;hidden&rdquo; behind some interface. So, we cannot easily deduce whether it would get converted or not.</li><li>There were some problems (described <a href=https://youtrack.jetbrains.com/issue/KT-24536>here</a>) leading to incorrect results when any element changed its <code>hashCode</code> value after being placed to the converted set.</li></ul><h3 id=since-kotlin-16>Since Kotlin 1.6<a hidden class=anchor aria-hidden=true href=#since-kotlin-16>#</a></h3><p>For the reasons mentioned above, the Kotlin team decided to remove this optimization entirely. Now, the second operand will <strong>never</strong> be converted to a <code>Set</code>. At most, it will be converted to a <code>List</code> if the operand is not implementing the <code>Collection</code> interface.</p><p>For a full list of affected API, see <a href=https://youtrack.jetbrains.com/issue/KT-45438>this link</a>.</p><p>Because this decision could potentially cause performance degradation in some cases, an inspection was added to inform about this issue offering an option to manually convert the second operand to a <code>Set</code>.</p><figure class=align-center><img loading=lazy src=/inspection.png#center alt="(The argument can be converted to &amp;lsquo;Set&amp;rsquo; to improve performance)" width=550><figcaption>Inspection in IntelliJ IDEA informing about a potential performance issue.<p>(The argument can be converted to &lsquo;Set&rsquo; to improve performance)</p></figcaption></figure><p>For now, it is possible to enable this optimization back on the JVM with a system property (<code>kotlin.collections.convert_arg_to_set_in_removeAll</code>). This will give more time to the developers that were previously relying on this feature to migrate the affected code.</p><p>Although, it is worth mentioning that the possibility of enabling the optimization back is planned to be removed in Kotlin 1.7. The same thing is going to happen to the inspection. It will be <strong>turned off</strong> by default with the next major release. Yet you will be able to turn it on again by going to <code>Preferences</code> -> <code>Editor</code> -> <code>Inspections</code> -> <code>Kotlin</code> -> <code>Other problems</code>.</p><p>They give the following explanation for their decision:</p><blockquote><p>However, we expect this inspection to be quite annoying in places where such time complexity does not that matter, so we plan to disabling it by default in the next version of Kotlin and leaving only an intention.</p></blockquote><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2><p>To summarize, here are the key points from this post:</p><ul><li>Since Kotlin 1.6, the second operands of some Kotlin Collection operations will no longer be converted to a Set under the hood.</li><li>That may have some performance implications, so an inspection was added to inform you about this issue whenever applicable.</li><li>However, the inspection will be turned off by default with the next major release of Kotlin (1.7). You might want to consider turning it on again if you think your codebase might benefit from having it.</li></ul></div><footer class=post-footer><nav class=paginav><a class=prev href=https://arkadiuszchmura.com/posts/how-to-reliably-update-widgets-on-android/><span class=title>« Prev Page</span><br><span>How to reliably update widgets on Android</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://arkadiuszchmura.com/>Arkadiusz Chmura</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>